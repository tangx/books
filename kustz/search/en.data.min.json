[{"id":0,"href":"/books/react/","title":"","parent":"","content":"react 18 notebook     所有文档      项目笔记  ","description":"react 18 notebook     所有文档      项目笔记  "},{"id":1,"href":"/books/react/SUMMARY/","title":"Summary","parent":"","content":"React 18 学习笔记      初始化项目  ","description":"React 18 学习笔记      初始化项目  "},{"id":2,"href":"/books/react/02-jsx/1-introduce/","title":"01. jsx 的介绍","parent":"2. jsx 基础用法","content":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。\n 可以到 Babel 官网查看编译后的结果\n其他      Babel 官网: https://babeljs.io/repl  ","description":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。"},{"id":3,"href":"/books/react/01-setup/01-initialize/","title":"01. 使用 create-react-app 快速搭建开发环境","parent":"1. 准备环境","content":"1. 设置 node.js 国内源      yarn config set registry https://registry.npm.taobao.org/ npm config set registry https://registry.npm.taobao.org/ 2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4. 清理文件     /src 是代码目录， 清理暂时不用的文件， 留下核心\n4.1. 删除文件     删除除了 index.js, App.js 以外的文件。\n此时， 需要在 index.js 和 App.js 中删除引用\ninjex.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; // import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; // import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; App.js, 删除引用文件， 并修改返回内容。\n// import logo from \u0026#39;./logo.svg\u0026#39;; // import \u0026#39;./App.css\u0026#39;;  function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); } export default App; 4.2. 关闭严格模式     在 index.js 中，注释 StrictMode\nconst root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 4.3. 关闭性能监控     在 index.js 中注释 reportWebVitals() 关闭性能监控\n// // If you want to start measuring performance in your app, pass a function // // to log results (for example: reportWebVitals(console.log)) // // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals // reportWebVitals(); 5. 说明     5.1. DOM 初始化     在 index.js 中,\n 通过 React.createRoot 创建了一个 DOM。 并通过 document.getElementById('root') 绑定到了 public/index.html 中的 root 节点上上。  // 这个 root 节点在 public/index.html 中定义。 const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 5.2. 组件     在 App.js 中\n// App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html function App() { return ( // return 出去  \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); }  组件的渲染流程大概如下: App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html 所有组件中都有一个 return 将结果丢给 React. 注意 \u0026lt;className=\u0026quot;App\u0026quot;\u0026gt; 不是 index 语法了， 而是 react 语法了。  其他      中文官网： https://zh-hans.react.dev/learn/start-a-new-react-project B站视频： https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=3\u0026amp;vd_source=0259bb47833cfe6d7c4749c69a49a9d2  ","description":"1. 设置 node.js 国内源      yarn config set registry https://registry.npm.taobao.org/ npm config set registry https://registry.npm.taobao.org/ 2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5."},{"id":4,"href":"/books/react/02-jsx/2-basic-syntax/","title":"02. jsx 的常用用法","parent":"2. jsx 基础用法","content":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 3. 函数调用      在 BasicSyntax 组建外部定义 函数 hello 在内部使用 {hello()} 调用。  注意： 调用函数时，必须要使用 圆括号() 函数才会被执行。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } 4. 方法调用     方法 本质上就是 具有一定限制函数。 因此方法调用与函数调用类似。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; {/* 字符串方法 */} \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; {/* 创建对象，并调用时间方法 */} \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 5. JS 对象调用     需要注意的是， 这里并不是使用的 双花括号 {{content}}， 而是两个不同意义的花括号。\n 外层 是 jsx 语法的花括号， 表示内部为 js 语法。 内层 是 js 语法的中 style 的定义 style={color:'red'}  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 6. 数学计算     数学计算\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 7. 注释      注释也是使用 花括号{} 开启 JS 语法 然后使用 JS 中的多行注释语法。  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } 其他     完整代码可以在 /src/components/jsx/BasicSyntax.js 中看到\nfunction BasicSyntax() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.2. jsx 基础语法\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } export default BasicSyntax; // 定义变量 let val = \u0026#39;this is const variable\u0026#39; // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } ","description":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2."},{"id":5,"href":"/books/react/02-jsx/3-list-render/","title":"03. 列表与字典渲染","parent":"2. jsx 基础用法","content":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，\n 使用 列表的 map 方法。 循环的是 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 标签， 就在循环中返回该标签。 标签属性 一定要使用 key。 且 key 的值 必须 是 唯一的 unique。  key 是 React 在进行渲染的时候做 diff 算法的标识。 如果不用， 在列表删除的时候就会出现数据偏差。    2. 不规范的省略写法     最常见的不规范写法， 就是省略了 唯一key\n(item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 打开控制台， 可以看到 警告 如下：\nWarning: Each child in a list should have a unique \u0026quot;key\u0026quot; prop.  function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;箭头函数 省略版： 有括号\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; { list.map((item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;)) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] 除此之外， 还有一种更省略的写法就是： 省略 圆括号， 这是 JS 的语法特性。\nlist.map(item =\u0026gt; \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 这两种都不是什么好的写法， 不用过多关注， 但是要知道可以这么写。\n其他:      React 的列表渲染 - 黑马 JS Array Usage  ","description":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，"},{"id":6,"href":"/books/react/02-jsx/4-conditional-render/","title":"04. 条件渲染","parent":"2. jsx 基础用法","content":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序\nLine 10:16: Unexpected mix of '\u0026amp;\u0026amp;' and '||'. Use parentheses to clarify the intended order of operations 因此我们可以通过 圆括号 进行归类， 注意括号未知。\n{(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} {isLogin \u0026amp;\u0026amp; (\u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;)} 2. 三目运算符     三目运算符 具有固定格式： condition? yes : no ， 注意分隔符。\nfunction ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;2. 三目运算符 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin ? Login : Logout\u0026lt;/p\u0026gt; {isLogin ? \u0026lt;Login /\u0026gt; : \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false; 3. 分支条件语句     分支条件语句\n 在 statement 中可以实现更复杂的操作 可以返回更多的 条件结果。  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;3. 分支函数\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;if (isLogin); return Login; else return Logout; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{Condition()}\u0026lt;/p\u0026gt; \u0026lt;/div \u0026gt; ) } const isLogin = false; function Condition() { if (isLogin) { {/* 其他操作 */} console.log(isLogin) return \u0026lt;Login /\u0026gt; } else { return \u0026lt;Logout /\u0026gt; } } 注意 Condition 由于 只有两个条件 结果， 非此即彼。因此函数还可以写成 以下形式 不用 else。\nfunction Condition() { if (isLogin) { return \u0026lt;Login /\u0026gt; } return \u0026lt;Logout /\u0026gt; } 其他:      如何渲染布尔值: String(bool1) jsx 简单条件渲染 jsx 复杂条件渲染  ","description":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序"},{"id":7,"href":"/books/react/03-event/onlick/","title":"1. OnClick Event","parent":"3. 事件绑定","content":" 事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意\n 需要使用 花括号{} 开启 jsx 执行函数(表达式)。 handler 函数 不需要被执行， 即没有跟 园括号。  function EventOnClick() { let count = 0 // 不接受参数  // 变量形式  const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 2. 接收事件参数     在事件触发是， React 是 默认 传递 事件参数 的，\n handler 函数只需要准备好 形参 接收即可。 在调用时 不需要 额外手工参数 实参。  这一点与 传递自定义参数 不同， 可以对比接下来的 第 3 点。\nfunction EventOnClick() { let count = 0 // 接收事件  // 函数形式  function handler2(event) { console.log(event) // count = count + 2  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler2}\u0026gt;button e\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 3. 接收自定义参数     其实就是在普通的 handler 函数的基础上， 在 调用 的时候使用 箭头 函数封装了一次。\n// 调用 onClick={() =\u0026gt; { handler3(count) }} 这里你可以看到有连个 花括号\n 外层： 是启用 jsx 的语法。 内层： 箭头函数的函数体边界。 其实这里也可以省略成以下形式  // 调用 onClick={() =\u0026gt; handler3(count) } 完整代码如下\nfunction EventOnClick() { let count = 0 // 接受参数  function handler3(n) { console.log(n); count = count + 3 } // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 注意这里是箭头函数 */} \u0026lt;button onClick={() =\u0026gt; { handler3(count) }}\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; handler3(count) }\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 4. 接收自定义参数与事件参数     同时接收 自定义参数 和 事件参数： 其实也很简单， 就是在上一个的技术上， 通过 箭头 函数获取了 事件参数， 再传给了 handler 函数。 可以说是 2,3 的结合体。\n注意： 在传递参数时， 需要注意参数的位置。\nfunction EventOnClick() { let count = 0 // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 1. 箭头函数， 2 参数位置 */} \u0026lt;button onClick={(event) =\u0026gt; { handler4(count, event) }}\u0026gt;button(+4,e)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 其他      Event handlers - React Learn  ","description":"事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意"},{"id":8,"href":"/books/react/01-setup/","title":"1. 准备环境","parent":"","content":"","description":""},{"id":9,"href":"/books/react/02-jsx/","title":"2. jsx 基础用法","parent":"","content":"","description":""},{"id":10,"href":"/books/react/03-event/","title":"3. 事件绑定","parent":"","content":"","description":""},{"id":11,"href":"/books/react/tags/","title":"Tags","parent":"","content":"","description":""}]
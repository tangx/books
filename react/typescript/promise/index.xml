<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>1. promise on React 18/19</title><link>https://typonotes.com/books/react/typescript/promise/</link><description>Recent content in 1. promise on React 18/19</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/typescript/promise/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Promise 用法简介</title><link>https://typonotes.com/books/react/typescript/promise/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/typescript/promise/intro/</guid><description>使用 ts 必须安装 @types/node
npm install @types/node 1. 回调地狱 （无限嵌套） // callback-hell.ts fs.readFile(&amp;#39;javascript/promise/title.txt&amp;#39;, &amp;#39;utf8&amp;#39;, (error, dataTitle) =&amp;gt; { fs.readFile(&amp;#39;javascript/promise/line1.txt&amp;#39;, &amp;#39;utf8&amp;#39;, (error, dataLine1) =&amp;gt; { fs.readFile(&amp;#39;javascript/promise/line2.txt&amp;#39;, &amp;#39;utf8&amp;#39;, (error, dataLine2) =&amp;gt; { const data = dataTitle + &amp;#39;\n&amp;#39; + dataLine1 + &amp;#39;\n&amp;#39; + dataLine2; console.log(data); }) }) }); 2. promise + async/await await 必须用于 async 函数中， 作用是 将异步函数变成同步函数 返回结果 依旧是 Promise // promise-readfile.</description></item><item><title>2. then-catch</title><link>https://typonotes.com/books/react/typescript/promise/then-catch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/typescript/promise/then-catch/</guid><description>1. Promise 状态 pending 待定: 初始状态，既没有被兑现，也没有被拒绝。 fulfilled 已兑现: 意味着操作成功完成。 rejected 已拒绝: 意味着操作失败。 2. then-catch 处理成功和失败 .then() 处理成功 (fulfilled) .catch() 处理失败 (rejected), catch 不是必须的， 可以省略 function promiseThenCatch(filename: string): void { readFilePromise(filename) .then((dataTitle) =&amp;gt; { // then 作用于 resolve， 成功 console.log(dataTitle); // 李白《静夜思》 return dataTitle; }) .catch((error) =&amp;gt; { // catch 作用于 reject， 失败 console.log(error); // Error { code: &amp;#39;ENOENT&amp;#39;, path: &amp;#39;javascript/promise/not-exist.</description></item><item><title>3. 创建 Promise 对象</title><link>https://typonotes.com/books/react/typescript/promise/new-promise/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/typescript/promise/new-promise/</guid><description>pending 待定: 初始状态，既没有被兑现，也没有被拒绝。 fulfilled 已兑现: 意味着操作成功完成。 rejected 已拒绝: 意味着操作失败。 创建 Promise 对象 使用 new Promise() 创建 Promise 对象 使用 泛型参数 Promise&amp;lt;&amp;gt; 创建执行 Promise 返回值类型。 如果不传递泛型参数 new Promise() 则， 返回值为 Promise&amp;lt;unknown&amp;gt;。 不会自动推断 resolve(value) 和 reject(reason) 都只能接受一个参数。 const c = 10 const p1 = new Promise&amp;lt;boolean&amp;gt;((resolve, reject) =&amp;gt; { if (c / 2 === 0) { resolve(true); } reject(false); }); 泛型约束只对 resolve 生效 泛型参数只对 resolve 的参数生效 reject 的参数永远是 any 。 pconst p2 = new Promise&amp;lt;boolean | number&amp;gt;((resolve, reject) =&amp;gt; { if (c % 2 === 0) { resolve(10); } reject(&amp;#39;a&amp;#39;); }); Promise 封装函数 function MyReadFile(filename: string) { fs.</description></item><item><title>resolve 和 reject 的返回状态</title><link>https://typonotes.com/books/react/typescript/promise/resolve-reject-status/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/typescript/promise/resolve-reject-status/</guid><description>resolve(value) 和 Promise.resolve(value) reject(reason) 和 Promise.reject(reason) Pomise.resolve 和 Promise.reject 是 对象方法， 不是 实例方法。 可以快速返回一个 Promise 实例。
其返回值的 状态 和 值 规则是一样的。
resolve 的不一定是 fulfilled resolve 返回的状态 依赖其返回值的状态。 可以看到 resolve 返回的是一个 PromiseLike 的对象， 所以 resolve 的返回状态其实就是 PromiseLike 对象的状态， 可能 fulfilled, 也可能是 rejected 。
如果 value 是一个 简单对象， 例如 boolean, string, number ， 则返回 状态为 fulfilled 如果 value 是一个 PromiseLike 的对象， 则 value 返回的 状态和值 即为当前 resolve 的状态和值。 const c = 10 // p 的返回永远是 rejected const p = new Promise((resolve, reject) =&amp;gt; { if (c % 2 === 0) { // p1 是一个 Promise 对象， 就是 p 返回值中的 PromiseLike const p1 = new Promise((resolve, reject) =&amp;gt; { reject(false); }); resolve(p1); } else { reject(false); } }); p.</description></item></channel></rss>
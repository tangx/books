<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>10. React on React18</title><link>https://typonotes.com/books/react/react/</link><description>Recent content in 10. React on React18</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/react/index.xml" rel="self" type="application/rss+xml"/><item><title>1. useState - ts</title><link>https://typonotes.com/books/react/react/react-ts/use-state-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/use-state-ts/</guid><description>1. 类型推导 类型推导的根本
不在于 是否简单类型还是复杂类型。 而是 在于初始化的时候，是否传入了明确的值。 如果有明确的值， 就可以推导。 // 简单类型推导 const [count, setCount] = useState(0); // const count: number // 复杂类型推导 const [names, setNames] = useState([&amp;#39;zhangsan&amp;#39;, &amp;#39;lisi&amp;#39;]); // const names: string[] // 自定义类型的类型推导 const p: Person = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [person, setPerson] = useState(p); // const person: Person 2. 泛型参数 没有明确初始化值的时候， 可以指定 泛型参数 明确类型约束 当指定了泛型参数后， 如果没有指定参数， 则变量为联合类型（ 指定类型 + undefined ） 如果指定了明确参数， 则为指定的类型 // 简单类型 // 只指定 泛型类型， 不指定默认参数。 变量类型为联合类型， 多一个 undefined const [name, setName] = useState&amp;lt;string&amp;gt;() // const name: string | undefined // 复杂类型 const [ages, setAges] = useState&amp;lt;Array&amp;lt;number&amp;gt;&amp;gt;() // const arr: number[] | undefined const [numbers, setNumbers] = useState&amp;lt;number[]&amp;gt;() // const arr: number[] | undefined // 自定类型 const [person, setPerson] = useState&amp;lt;IPerson&amp;gt;() // const person: IPerson | undefined // 同时指定 泛型类型 和 指定参数。 变量类型固定。 const zhangsan: IPerson = { name: &amp;#39;zhangsan&amp;#39;, age: 18 } const [user, setUser] = useState&amp;lt;IPerson&amp;gt;(zhangsan) // const user: IPerson 3.</description></item><item><title>2. props - ts</title><link>https://typonotes.com/books/react/react/react-ts/props-ts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/react-ts/props-ts/</guid><description>1. 使用 type 或者 interface 注解 props 注解的本质， 就是 限定函数参数类型。
可是使用 type 或者 interface 进行注解 在使用 props 的时候 传递整个对象: const TypeProps = (props: Props) =&amp;gt; {} 解耦部分字段，注意不能省略注解类型: const IterfaceProps = ({ name }: IProps) =&amp;gt; {} type Props = { name: string age: number } // 使用 Type 注解 // 获取整个 props const TypeProps = (props: Props) =&amp;gt; { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;Props Basic&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{props.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React18</title><link>https://typonotes.com/books/react/</link><description>Recent content on React18</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/react/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://typonotes.com/books/react/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/SUMMARY/</guid><description>React 18 学习笔记 初始化项目</description></item><item><title>01. B站评论</title><link>https://typonotes.com/books/react/demos/bili-comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/demos/bili-comment/</guid><description>1. 安装 sass 支持 npm install sass 2. 评论 使用 useState 管理评论状态
const [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染 { BiliComments.map( item =&amp;gt; &amp;lt;div className=&amp;#34;content-wrap&amp;#34; key={item.rpid}&amp;gt; // ... &amp;lt;/div&amp;gt; ) } 2.2. 删除按钮： 条件渲染 {user.uid === item.user.uid &amp;amp;&amp;amp; &amp;lt;span&amp;gt;删除&amp;lt;/span&amp;gt;} 2.3. 删除事件: 点击效果 需要使用一个箭头函数， 实现 点击触发 的效果。</description></item><item><title>1. jsx 的介绍</title><link>https://typonotes.com/books/react/react/jsx/introduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/introduce/</guid><description>之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。
这是一个带有变量的例子
// 定义 变量 const message = &amp;#34;this is a message&amp;#34; function App() { // return 中的内容是 jsx 语法 return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; // className 不是 HTML 语法 {message} // 使用变量 &amp;lt;/div&amp;gt; ); } 1. 什么是 jsx jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。
可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。 由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。</description></item><item><title>1. onClick 点击事件</title><link>https://typonotes.com/books/react/react/events/on-click/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-click/</guid><description>事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式 // 不接受参数 // 变量形式 const handler1 = () =&amp;gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。
1. 不接受参数 这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。
&amp;lt;button onClick={handler1}&amp;gt;button +1&amp;lt;/button&amp;gt; 如上， 是在 button 中接收了的 onClick 事件。 注意</description></item><item><title>1. 基础语法</title><link>https://typonotes.com/books/react/react/hooks/use-effect/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/basic/</guid><description>1. 语法规则 import { useEffect } from &amp;#39;react&amp;#39; useEffect(()=&amp;gt;{}, []) useEffect 支持两个参数
参数一是 函数 ()=&amp;gt;{}。 可以称其为 副作用函数， 在函数内部可以放置要执行的操作。 如果函数由返回值， 则表示在 组件卸载时执行， 这个后面讨论。 参数二是 数组 []（可选）， 在数组里放置 依赖项。 不同依赖项数据量导致渲染行为不一致， 这个后面讨论。 在 /src/components/hooks/UseEffectBasic.jsx 中
import { useEffect, useState } from &amp;#34;react&amp;#34; const URL = &amp;#39;http://geek.itheima.net/v1_0/channels&amp;#39; export default function UseEffectBasic() { const [channels, setChannels] = useState([]) // 定义副作用函数， 只执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>1. 支持的数据类型</title><link>https://typonotes.com/books/react/react/communication/props/props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/props/</guid><description>/src/components/communication/Parent2Children.jsx
props 可以传递任意数据 数字, 字符串, 布尔值 数组, 对象 函数, JSX function Parent() { return ( &amp;lt;div&amp;gt; &amp;lt;Child name={&amp;#34;Wangwu&amp;#34;} age={20} isTrue={true} list={[1, 2, 3]} obj={{ name: &amp;#34;Zhaoliu&amp;#34; }} func={() =&amp;gt; { console.log(&amp;#34;Hello&amp;#34;) }} child={&amp;lt;span&amp;gt;this is a span&amp;lt;/span&amp;gt;} /&amp;gt; &amp;lt;/div&amp;gt; ); } props 是 只读对象: 子组件 只能读取 props 中的数据， 不能直接修改。 如果要修改， 只能在父组件中 由父组件修改。 参考 子传父通信 3. 兄弟通信 状态提升</description></item><item><title>1. 组件式开发</title><link>https://typonotes.com/books/react/react/components/what-is-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/what-is-component/</guid><description>1. 组件是什么 组件是用户界面的一部分， 他可以有自己的的逻辑和外观。
组件之间 可以互相嵌套 组件 可以多次重复使用 组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。
2. 如何定义组件</description></item><item><title>1. 配置开发环境</title><link>https://typonotes.com/books/react/setup/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/install/</guid><description>安装 NodeJS 安装 NodeJS wget -c https://nodejs.org/dist/v20.11.0/node-v20.11.0-darwin-arm64.tar.gz tar xf node-v20.11.0-darwin-arm64.tar.gz mv node-v20.11.0-darwin-arm64 /usr/local/nodejs 配置环境变量 export NODE_ROOT=/usr/local/nodejs export PATH=$NODE_ROOT/bin:$PATH alias cnpm=&amp;#39;npm --registry=https://registry.npmmirror.com &amp;#39; 配置国内源 yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com Chrome 插件 React Developer Tools</description></item><item><title>2. context 跨层级通信</title><link>https://typonotes.com/books/react/react/communication/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/context/</guid><description>和 Golang 的 context 差不多。 在 context.Provider 下的所有节点都可以通过关键字 useContext 获取数据。
解决了 props 中不相关的组件之间需要传递数据时 状态提升 的复杂操作。
使用 createContext 方法创建一个 上下文对象 Ctx 在顶层组件 (如图, App) 中使用 Ctx.Provider 组件提供数据。 在下层组件 (如图, B) 中使用 useContext 钩子获取消费数据。 在 /src/components/communication/UseContext.jsx 中， 定义三个组件形成嵌套关系
UseContext, 对应上图中的 App A 对应 A B 对应 B 1. 定义 MsgContext 在文件级别， 使用 createContext 创建 Context 对象
注意: 经测试， 创建时提供的 default value 并不起作用。 实际 可用数据 还是需要在 &amp;lt;MsgContext.</description></item><item><title>2. jsx 的常用用法</title><link>https://typonotes.com/books/react/react/jsx/basic-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/basic-syntax/</guid><description>在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。
常见的包括
常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等 1. 常量调用 在 BasicSyntax 内部使用 {'this is const string'}
// BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;1. 常量调用&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{&amp;#39;this is const string&amp;#39;}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); } 2. 变量调用 在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用 // BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;2.</description></item><item><title>2. onChange 数据双向绑定</title><link>https://typonotes.com/books/react/react/events/on-change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/events/on-change/</guid><description>在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即
使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。 // Path: src/components/event/EventOnClick.js import { useState } from &amp;#34;react&amp;#34; export default function EventOnChange() { const [username, setUsername] = useState(&amp;#34;zhangsan&amp;#34;) return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;OnChange 事件实现数据双向绑定&amp;lt;/h2&amp;gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2.</description></item><item><title>2. 不同依赖项行为</title><link>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/dependencies/</guid><description>2. 不同依赖项的不同渲染行为 不同状态 的数组影响第一参数函数的执行。 1. 数据被省略时： 在组件加载时执行， 且在任意渲染时执行。 2. 数组为空时： 仅在组件加载时执行 （仅执行一次）。 3. 数组中有依赖项时： 在组件加载时执行， 且在 仅在依赖项变化时触发的渲染时执行
在 /src/components/hooks/UseEffectDependencies.jsx 中
import { useState, useEffect } from &amp;#34;react&amp;#34;; export default function UseEffectDependencies() { const [count, setCount] = useState(0) const [trigger, setTrigger] = useState(0) // (1) none dependency // 组件加载时，执行一次 // 无依赖项，每次组件更新时，都会执行 useEffect(() =&amp;gt; { console.log(&amp;#39;NONE: useEffect called&amp;#39;); }); // (2) empty dependency // 仅在组件加载时执行一次 useEffect(() =&amp;gt; { console.</description></item><item><title>2. 初始化项目</title><link>https://typonotes.com/books/react/setup/initialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/setup/initialize/</guid><description>2. 创建项目 npx create-react-app react-basic npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。 3. 项目配置 ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令
// 依赖组建 &amp;quot;dependencies&amp;quot;: { &amp;quot;@testing-library/jest-dom&amp;quot;: &amp;quot;^5.17.0&amp;quot;, &amp;quot;@testing-library/react&amp;quot;: &amp;quot;^13.4.0&amp;quot;, &amp;quot;@testing-library/user-event&amp;quot;: &amp;quot;^13.5.0&amp;quot;, &amp;quot;react&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-dom&amp;quot;: &amp;quot;^18.2.0&amp;quot;, &amp;quot;react-scripts&amp;quot;: &amp;quot;5.0.1&amp;quot;, &amp;quot;web-vitals&amp;quot;: &amp;quot;^2.1.4&amp;quot; }, // 启动命令 &amp;quot;scripts&amp;quot;: { &amp;quot;start&amp;quot;: &amp;quot;react-scripts start&amp;quot;, &amp;quot;build&amp;quot;: &amp;quot;react-scripts build&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;react-scripts test&amp;quot;, &amp;quot;eject&amp;quot;: &amp;quot;react-scripts eject&amp;quot; }, 4.</description></item><item><title>2. 如何定义组件</title><link>https://typonotes.com/books/react/react/components/define-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/components/define-component/</guid><description>组件的定义方式有两种。
函数式组件： 最常用 类式组件 组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰
例如， MyButton, UserInfoDisplay
1. 组件的定义 1.1. 函数式组件 在 /src/components/component/FuncComponent.js 中
function FunctionButtion() { return ( &amp;lt;button&amp;gt;function buttion&amp;lt;/button&amp;gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件 箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中
export const ArrowFuncButtion = () =&amp;gt; { return ( &amp;lt;button&amp;gt;arrow func button&amp;lt;/button&amp;gt; ) } 1.3. 类式组件 这个有有点特别了， 在 React 18 中， 已经不怎么用了。</description></item><item><title>2. 父传子通信</title><link>https://typonotes.com/books/react/react/communication/props/parent-to-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/parent-to-children/</guid><description>/src/components/communication/Parent2Children.jsx
实现步骤
传递数据: 父组件 在 子组件 上 绑定属性 接收数据: 子组件 使用 props 参数接收数据。 function Parent() { const name = &amp;#34;Zhangsan&amp;#34;; const age = 18; return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Parent Area: &amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;name=Zhangsan, age=18&amp;lt;/span&amp;gt; {/* 1. 通过属性给 Child 传递数据 */} &amp;lt;Child name={name} age={age} /&amp;gt; &amp;lt;/div&amp;gt; ); } // 2. 定义的时候， 使用 props 接收参数 function Child(props) { // 打印所有 props console.log(props); return ( &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;Child Area: &amp;lt;/span&amp;gt; {/* 3. 使用的时候， 使用 props.</description></item><item><title>3. 列表与字典渲染</title><link>https://typonotes.com/books/react/react/jsx/list-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/list-render/</guid><description>代码在 /src/components/jsx/ListRender.js 中
列表默认情况是这样的
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;liubei&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;guanyu&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;zhangfei&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 1. 标准版的渲染 const list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;] function ListRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;2.3. 循环渲染&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;]&amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt;箭头函数， 完整版。 带 key &amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; // (1) 保留外城的 ul { list.map((item, index) =&amp;gt; { // (2) 循环什么就返回什么。 // (3) key 是 React 渲染的唯一表示 return &amp;lt;li key={index}&amp;gt;{item}&amp;lt;/li&amp;gt; }) } &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ) } 当我们要进行 列表渲染 的时候，</description></item><item><title>3. 清理副作用</title><link>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-effect/clear-side-effect/</guid><description>3. 清除函数副作用 useEffect 的第一个参数时一个函数。 当该函数有 return 返回值 statement 的时候， 会在 组件被卸载/取消挂载 的时候执行。
如下代码， return 返回的 箭头函数 会在其所在的组件的组件被卸载的时候 停止计时器 。
useEffect( () =&amp;gt; { const id = setInterval(() =&amp;gt; { console.log(&amp;#39;Child: setInterval called&amp;#39;); }, 1000); // 当省略清理函数时， // 组件卸载时，定时器不会被清除 // 当重新加载组件时，会创建新的定时器， 多个定时器会同时运行 return () =&amp;gt; { clearInterval(id); } }, [] // 依赖项为空数组，只有在加载时执行一次， 只有在组件卸载时才会执行清理函数 ) 如果没有这段 return 清空计时器的代码， 那么当所在组件 反复 被挂载时， 每次加载都会启动一个新的定时器， 结果就是 启动无数个 计时器。</description></item><item><title>3. 特殊的 children 插槽</title><link>https://typonotes.com/books/react/react/communication/props/slot-children/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/slot-children/</guid><description>/src/components/communication/RootCommunication.jsx
export default function RootCommunication() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt; 7. 组件通信&amp;lt;/h2&amp;gt; {/* 1. 自闭和标签 */} &amp;lt;Parent2Children /&amp;gt; {/* 2. 成对标签， 默认插槽 */} &amp;lt;PropChild&amp;gt; &amp;lt;span&amp;gt;span1&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;span2&amp;lt;/span&amp;gt; &amp;lt;/PropChild&amp;gt; &amp;lt;/div&amp;gt; ); } 可以看到在使用 PropChild
使用的是 成对标签。 标签中放入了两个 span 标签。 function PropChild(props) { return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;7.1. 特殊的 props.children&amp;lt;/h3&amp;gt; {/* 拿到默认的 children 属性 */} &amp;lt;span&amp;gt;prop child: {props.children}&amp;lt;/span&amp;gt; &amp;lt;hr /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 PropChild 内部， 使用 props.children 拿到了传过来的标签值
使用 React Developer Tool 可以更清晰的看到其属性</description></item><item><title>4. 子传父通信</title><link>https://typonotes.com/books/react/react/communication/props/children-to-parent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/children-to-parent/</guid><description>/src/components/communication/Children2Parent.jsx
核心思路: 父组件可以给子组件传递一个函数， 子组件通过调用函数向父组件传递数据
父组件通过 props 向子组件传递数据， 但 在子组件中 props 是只读的。 因此 数据只能在父组件中被修改 function Parent() { const original = &amp;#34;Father.React&amp;#34; // 在父组件定义一个状态数据 const [name, setName] = useState(original) // 重置名字 function resetName() { setName(original) } // 1. 通过函数修改父组件的状态数据 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;父组件名字: {name}&amp;lt;/p&amp;gt; &amp;lt;b&amp;gt;父组件区域: &amp;lt;/b&amp;gt; &amp;lt;button onClick={resetName}&amp;gt;重置名称&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;重置父组件名字&amp;lt;/span&amp;gt; {/* 1. 通过 props 将函数传递给子组件 2. props 属性名字加上 on 表示调用执行 */} &amp;lt;hr&amp;gt;&amp;lt;/hr&amp;gt; &amp;lt;Child onChangeName={changeName} /&amp;gt; &amp;lt;/div&amp;gt; ) } 在 父组件中</description></item><item><title>4. 条件渲染</title><link>https://typonotes.com/books/react/react/jsx/conditional-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/conditional-render/</guid><description>React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种
逻辑判断： &amp;amp;&amp;amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch 1. 逻辑运算符 逻辑运算符：
&amp;amp;&amp;amp; 且 || 或 ! 非 function ConditionalRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;04. 条件渲染: isLogin={String(isLogin)}&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;1. 逻辑语句&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login &amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;} &amp;lt;p&amp;gt;isLogin || Logout&amp;lt;/p&amp;gt; {isLogin || &amp;lt;Logout /&amp;gt;} &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login || Logout&amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt; || &amp;lt;Logout /&amp;gt;} {(isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;) || &amp;lt;Logout /&amp;gt;} &amp;lt;/div &amp;gt; ) } const isLogin = false; 条件语句 必须要在最前面。 &amp;amp;&amp;amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。 但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 &amp;amp;&amp;amp; 和 ||。 请用 圆括号 指定执行顺序</description></item><item><title>5. 兄弟通信</title><link>https://typonotes.com/books/react/react/communication/props/brothers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/communication/props/brothers/</guid><description>/src/components/communication/Brothers.jsx
兄弟组件没有关联关系， 因此需要 通过共同的父组件 进行数据的传递。 这并不是一个新东西， 而是将 父传子、子传父 组合案例。
function Parent() { // 1. 在父节点定义状态数据 const [name, setName] = useState(&amp;#34;&amp;#34;) // 2. 在父节点定义修改状态数据的方法 function changeName(name) { setName(name) } return ( &amp;lt;div&amp;gt; {/* 3. 给 Child A 传递修改数据方法 */} &amp;lt;ChildA onChangeName={changeName} /&amp;gt; {/* 3. 给 Child B 传递数据 */} &amp;lt;ChildB name={name} /&amp;gt; &amp;lt;/div&amp;gt; ); } 在 父节点
使用 useState 定义状态数据 name 定义 修改函数 changeName 将修改传输传递给 ChildA, 将状态数据传递给 ChildB function ChildA({ onChangeName }) { return ( &amp;lt;div&amp;gt; &amp;lt;b&amp;gt;Child A: &amp;lt;/b&amp;gt; {/* 4.</description></item><item><title>5. 样式的使用</title><link>https://typonotes.com/books/react/react/jsx/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/jsx/style/</guid><description>源代码在 /src/components/styles/RootStyle.jsx
1. 行内样式 在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。
&amp;lt;p style={{ color: &amp;#34;red&amp;#34;, fontSize: &amp;#34;18px&amp;#34; }}&amp;gt;1.1. 行内样式&amp;lt;/p&amp;gt; 外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =&amp;gt; fontSize 向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。
export default function RootStyle() { return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p style={style}&amp;gt;1.2. 行内样式2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } const style = { color: &amp;#34;blue&amp;#34;, fontSize: &amp;#34;18px&amp;#34; } 2.</description></item><item><title>classnames</title><link>https://typonotes.com/books/react/library/chassnames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/chassnames/</guid><description> 项目地址: https://github.com/JedWatson/classnames
安装方式 npm install classnames Demo import classNames from &amp;#39;classnames&amp;#39;; classNames(&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames(&amp;#39;foo&amp;#39;, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: true }); // =&amp;gt; &amp;#39;foo-bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: false }); // =&amp;gt; &amp;#39;&amp;#39; classNames({ foo: true }, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ foo: true, bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; // lots of arguments of various types classNames(&amp;#39;foo&amp;#39;, { bar: true, duck: false }, &amp;#39;baz&amp;#39;, { quux: true }); // =&amp;gt; &amp;#39;foo bar baz quux&amp;#39; // other falsy values are just ignored classNames(null, false, &amp;#39;bar&amp;#39;, undefined, 0, { baz: null }, &amp;#39;&amp;#39;); // =&amp;gt; &amp;#39;bar&amp;#39;</description></item><item><title>dayjs 时间处理</title><link>https://typonotes.com/books/react/library/dayjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/dayjs/</guid><description>dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。
官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js 1. install
npm install dayjs 2. Usage
import dayjs from &amp;#39;dayjs&amp;#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(&amp;#39;YYYY-MM-DD HH:mm:ss&amp;#39;) // 2023-03-18 19:33:24 更多直接查看官网。</description></item><item><title>lodash 工具库</title><link>https://typonotes.com/books/react/library/lodash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/lodash/</guid><description/></item><item><title>sass</title><link>https://typonotes.com/books/react/lang/css/sass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/lang/css/sass/</guid><description>npm install sass</description></item><item><title>useContext 数据传递</title><link>https://typonotes.com/books/react/react/hooks/use-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-context/</guid><description/></item><item><title>useImmer 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-immer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-immer/</guid><description>useImmer 是 useState 的 加强版。
https://github.com/immerjs/use-immer npm install immer use-immer</description></item><item><title>useRef 获取 DOM</title><link>https://typonotes.com/books/react/react/hooks/use-ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-ref/</guid><description>在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数
import { useRef } from &amp;#39;react&amp;#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象 const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象 console.log(inputRef.current); // 使用 console.dir 展开 ref 对象 console.dir(inputRef.current); // 焦点锁定 inputRef.current.focus() } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;3. useRef 获取 DOM&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;点击 Button 在控制台查看输出&amp;lt;/p&amp;gt; {/* 将 ref 绑定到标签属性上 */} &amp;lt;input type=&amp;#34;text&amp;#34; ref={inputRef} /&amp;gt; {/* 3.</description></item><item><title>useState 状态数据</title><link>https://typonotes.com/books/react/react/hooks/use-state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/react/hooks/use-state/</guid><description>React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。
如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)
使用 useState 时， 需要先导入。 import { useState } from &amp;#34;react&amp;#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。 count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。 // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。</description></item><item><title>uuid</title><link>https://typonotes.com/books/react/library/uuid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/react/library/uuid/</guid><description>uuid 生成 UUID 随机数。
https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install npm install uuid 2. Create a UUID (ES6 module syntax)
import { v4 as uuidv4 } from &amp;#39;uuid&amp;#39;; uuidv4(); // ⇨ &amp;#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&amp;#39; &amp;hellip; or using CommonJS syntax:
const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39; const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39;</description></item></channel></rss>
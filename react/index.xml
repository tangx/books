<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>《React 18 step by step》</title><link>https://typenotes.com/books/react/</link><description>Recent content on 《React 18 step by step》</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typenotes.com/books/react/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://typenotes.com/books/react/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/SUMMARY/</guid><description>React 18 学习笔记 初始化项目</description></item><item><title>01. B站评论</title><link>https://typenotes.com/books/react/demos/bili-comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/demos/bili-comment/</guid><description>1. 安装 sass 支持 npm install sass 2. 评论 使用 useState 管理评论状态
const [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染 { BiliComments.map( item =&amp;gt; &amp;lt;div className=&amp;#34;content-wrap&amp;#34; key={item.rpid}&amp;gt; // ... &amp;lt;/div&amp;gt; ) } 2.2. 删除按钮： 条件渲染 {user.uid === item.user.uid &amp;amp;&amp;amp; &amp;lt;span&amp;gt;删除&amp;lt;/span&amp;gt;} 2.3. 删除事件: 点击效果 需要使用一个箭头函数， 实现 点击触发 的效果。</description></item><item><title>1. jsx 的介绍</title><link>https://typenotes.com/books/react/react/jsx/introduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/jsx/introduce/</guid><description>之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。
这是一个带有变量的例子
// 定义 变量 const message = &amp;#34;this is a message&amp;#34; function App() { // return 中的内容是 jsx 语法 return ( &amp;lt;div className=&amp;#34;App&amp;#34;&amp;gt; // className 不是 HTML 语法 {message} // 使用变量 &amp;lt;/div&amp;gt; ); } 1. 什么是 jsx jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。
可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。 由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。</description></item><item><title>1. OnClick 点击事件</title><link>https://typenotes.com/books/react/react/events/on-click/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/events/on-click/</guid><description>事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式 // 不接受参数 // 变量形式 const handler1 = () =&amp;gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。
1. 不接受参数 这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。
&amp;lt;button onClick={handler1}&amp;gt;button +1&amp;lt;/button&amp;gt; 如上， 是在 button 中接收了的 onClick 事件。 注意</description></item><item><title>1. 组件式开发</title><link>https://typenotes.com/books/react/react/components/what-is-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/components/what-is-component/</guid><description>1. 组件是什么 组件是用户界面的一部分， 他可以有自己的的逻辑和外观。
组件之间 可以互相嵌套 组件 可以多次重复使用 组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。
2. 如何定义组件</description></item><item><title>1. 配置开发环境</title><link>https://typenotes.com/books/react/setup/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/setup/install/</guid><description/></item><item><title>2. jsx 的常用用法</title><link>https://typenotes.com/books/react/react/jsx/basic-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/jsx/basic-syntax/</guid><description>在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。
常见的包括
常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等 1. 常量调用 在 BasicSyntax 内部使用 {'this is const string'}
// BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;1. 常量调用&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;{&amp;#39;this is const string&amp;#39;}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); } 2. 变量调用 在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用 // BasicSyntax 基础语法组建 function BasicSyntax() { return ( &amp;lt;div className=&amp;#34;BasicSyntax&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;2.</description></item><item><title>2. onChange 数据双向绑定</title><link>https://typenotes.com/books/react/react/events/on-change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/events/on-change/</guid><description>在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即
使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。 // Path: src/components/event/EventOnClick.js import { useState } from &amp;#34;react&amp;#34; export default function EventOnChange() { const [username, setUsername] = useState(&amp;#34;zhangsan&amp;#34;) return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;OnChange 事件实现数据双向绑定&amp;lt;/h2&amp;gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2.</description></item><item><title>2. 初始化项目</title><link>https://typenotes.com/books/react/setup/initialize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/setup/initialize/</guid><description>1. 设置 node.js 国内源 # # https://registry.npm.taobao.org/ yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com 2. 创建项目 npx create-react-app react-basic npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。 3. 项目配置 ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令</description></item><item><title>2. 如何定义组件</title><link>https://typenotes.com/books/react/react/components/define-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/components/define-component/</guid><description>组件的定义方式有两种。
函数式组件： 最常用 类式组件 组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰
例如， MyButton, UserInfoDisplay
1. 组件的定义 1.1. 函数式组件 在 /src/components/component/FuncComponent.js 中
function FunctionButtion() { return ( &amp;lt;button&amp;gt;function buttion&amp;lt;/button&amp;gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件 箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中
export const ArrowFuncButtion = () =&amp;gt; { return ( &amp;lt;button&amp;gt;arrow func button&amp;lt;/button&amp;gt; ) } 1.3. 类式组件 这个有有点特别了， 在 React 18 中， 已经不怎么用了。</description></item><item><title>3. 列表与字典渲染</title><link>https://typenotes.com/books/react/react/jsx/list-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/jsx/list-render/</guid><description>代码在 /src/components/jsx/ListRender.js 中
列表默认情况是这样的
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;liubei&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;guanyu&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;zhangfei&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 1. 标准版的渲染 const list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;] function ListRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;2.3. 循环渲染&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; list = [&amp;#39;liubei&amp;#39;, &amp;#39;guanyu&amp;#39;, &amp;#39;zhangfei&amp;#39;]&amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt;箭头函数， 完整版。 带 key &amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; // (1) 保留外城的 ul { list.map((item, index) =&amp;gt; { // (2) 循环什么就返回什么。 // (3) key 是 React 渲染的唯一表示 return &amp;lt;li key={index}&amp;gt;{item}&amp;lt;/li&amp;gt; }) } &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ) } 当我们要进行 列表渲染 的时候，</description></item><item><title>4. 条件渲染</title><link>https://typenotes.com/books/react/react/jsx/conditional-render/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/jsx/conditional-render/</guid><description>React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种
逻辑判断： &amp;amp;&amp;amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch 1. 逻辑运算符 逻辑运算符：
&amp;amp;&amp;amp; 且 || 或 ! 非 function ConditionalRender() { return ( &amp;lt;div&amp;gt; &amp;lt;h2&amp;gt;04. 条件渲染: isLogin={String(isLogin)}&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;1. 逻辑语句&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login &amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;} &amp;lt;p&amp;gt;isLogin || Logout&amp;lt;/p&amp;gt; {isLogin || &amp;lt;Logout /&amp;gt;} &amp;lt;p&amp;gt;isLogin &amp;amp;&amp;amp; Login || Logout&amp;lt;/p&amp;gt; {isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt; || &amp;lt;Logout /&amp;gt;} {(isLogin &amp;amp;&amp;amp; &amp;lt;Login /&amp;gt;) || &amp;lt;Logout /&amp;gt;} &amp;lt;/div &amp;gt; ) } const isLogin = false; 条件语句 必须要在最前面。 &amp;amp;&amp;amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。 但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 &amp;amp;&amp;amp; 和 ||。 请用 圆括号 指定执行顺序</description></item><item><title>5. 样式的使用</title><link>https://typenotes.com/books/react/react/jsx/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/jsx/style/</guid><description>源代码在 /src/components/styles/RootStyle.jsx
1. 行内样式 在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。
&amp;lt;p style={{ color: &amp;#34;red&amp;#34;, fontSize: &amp;#34;18px&amp;#34; }}&amp;gt;1.1. 行内样式&amp;lt;/p&amp;gt; 外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =&amp;gt; fontSize 向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。
export default function RootStyle() { return ( &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p style={style}&amp;gt;1.2. 行内样式2&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) } const style = { color: &amp;#34;blue&amp;#34;, fontSize: &amp;#34;18px&amp;#34; } 2.</description></item><item><title>classnames</title><link>https://typenotes.com/books/react/library/chassnames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/library/chassnames/</guid><description> 项目地址: https://github.com/JedWatson/classnames
安装方式 npm install classnames Demo import classNames from &amp;#39;classnames&amp;#39;; classNames(&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames(&amp;#39;foo&amp;#39;, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: true }); // =&amp;gt; &amp;#39;foo-bar&amp;#39; classNames({ &amp;#39;foo-bar&amp;#39;: false }); // =&amp;gt; &amp;#39;&amp;#39; classNames({ foo: true }, { bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; classNames({ foo: true, bar: true }); // =&amp;gt; &amp;#39;foo bar&amp;#39; // lots of arguments of various types classNames(&amp;#39;foo&amp;#39;, { bar: true, duck: false }, &amp;#39;baz&amp;#39;, { quux: true }); // =&amp;gt; &amp;#39;foo bar baz quux&amp;#39; // other falsy values are just ignored classNames(null, false, &amp;#39;bar&amp;#39;, undefined, 0, { baz: null }, &amp;#39;&amp;#39;); // =&amp;gt; &amp;#39;bar&amp;#39;</description></item><item><title>context 跨层级通信</title><link>https://typenotes.com/books/react/react/comunication/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/comunication/context/</guid><description/></item><item><title>dayjs 时间处理</title><link>https://typenotes.com/books/react/library/dayjs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/library/dayjs/</guid><description>dayjs 是一款 nodejs 的 时间 处理库。 与 js 原生时间库 Date 相比， 更好用。
官网: https://day.js.org/docs/en/installation/typescript 中文网: https://dayjs.fenxianglu.cn/category/#node-js 1. install
npm install dayjs 2. Usage
import dayjs from &amp;#39;dayjs&amp;#39; // https://day.js.org/docs/en/parse/string-format dayjs().format(&amp;#39;YYYY-MM-DD HH:mm:ss&amp;#39;) // 2023-03-18 19:33:24 更多直接查看官网。</description></item><item><title>lodash 工具库</title><link>https://typenotes.com/books/react/library/lodash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/library/lodash/</guid><description/></item><item><title>props 通信</title><link>https://typenotes.com/books/react/react/comunication/props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/comunication/props/</guid><description>1. 父传子通信 1.1 children 说明 2. 子传父通信 3. 兄弟通信 状态提升</description></item><item><title>sass</title><link>https://typenotes.com/books/react/lang/css/sass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/lang/css/sass/</guid><description>npm install sass</description></item><item><title>useContext 数据传递</title><link>https://typenotes.com/books/react/react/hooks/use-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/hooks/use-context/</guid><description/></item><item><title>useImmer 状态数据</title><link>https://typenotes.com/books/react/react/hooks/use-immer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/hooks/use-immer/</guid><description>useImmer 是 useState 的 加强版。
https://github.com/immerjs/use-immer npm install immer use-immer</description></item><item><title>useRef 获取 DOM</title><link>https://typenotes.com/books/react/react/hooks/use-ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/hooks/use-ref/</guid><description>在 React 中 获取/操作 DOM， 需要使用 useRef 钩子函数
import { useRef } from &amp;#39;react&amp;#39;; export default function UseRef() { // 1. 使用 useRef 生成 ref 对象 const inputRef = useRef(null); function showDOM() { // 使用 console.log 查看 ref 对象 console.log(inputRef.current); // 使用 console.dir 展开 ref 对象 console.dir(inputRef.current); // 焦点锁定 inputRef.current.focus() } return ( &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;3. useRef 获取 DOM&amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt;点击 Button 在控制台查看输出&amp;lt;/p&amp;gt; {/* 将 ref 绑定到标签属性上 */} &amp;lt;input type=&amp;#34;text&amp;#34; ref={inputRef} /&amp;gt; {/* 3.</description></item><item><title>useState 状态数据</title><link>https://typenotes.com/books/react/react/hooks/use-state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/react/hooks/use-state/</guid><description>React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。
如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)
使用 useState 时， 需要先导入。 import { useState } from &amp;#34;react&amp;#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。 count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。 // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。</description></item><item><title>uuid</title><link>https://typenotes.com/books/react/library/uuid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typenotes.com/books/react/library/uuid/</guid><description>uuid 生成 UUID 随机数。
https://github.com/uuidjs/uuid https://www.npmjs.com/package/uuid 1. Install npm install uuid 2. Create a UUID (ES6 module syntax)
import { v4 as uuidv4 } from &amp;#39;uuid&amp;#39;; uuidv4(); // ⇨ &amp;#39;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&amp;#39; &amp;hellip; or using CommonJS syntax:
const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39; const { v4: uuidv4 } = require(&amp;#39;uuid&amp;#39;); uuidv4(); // ⇨ &amp;#39;1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed&amp;#39;</description></item></channel></rss>
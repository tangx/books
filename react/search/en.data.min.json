[{"id":0,"href":"/books/react/","title":"","parent":"","content":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    ","description":"react 18 notebook     所有文档      项目笔记  资源      黑马程序员前端React18入门到实战视频教程  React18 - 配套资料    "},{"id":1,"href":"/books/react/SUMMARY/","title":"Summary","parent":"","content":"React 18 学习笔记      初始化项目  ","description":"React 18 学习笔记      初始化项目  "},{"id":2,"href":"/books/react/99-demos/bili-comment/","title":"01. B站评论","parent":"99. 项目案例","content":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。\nfunction deleteComment(rpid) { setBiliComments(BiliComments.filter(item =\u0026gt; item.rpid !== rpid)) } \u0026lt;span className=\u0026#34;delete-btn\u0026#34; onClick={() =\u0026gt; deleteComment(item.rpid)} \u0026gt;删除\u0026lt;/span\u0026gt; 2.4. 更新评论: 使用 filter 实现数据删除     const newList = BiliComments.filter(item =\u0026gt; item.rpid !== rpid) setBiliComments(newList) 2.5 头像: 添加标签     使用 src 属性展示头像\n\u0026lt;div className=\u0026#34;bili-avatar\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;bili-avatar-img\u0026#34; alt=\u0026#34;\u0026#34; src={item.user.avatar} /\u0026gt; \u0026lt;/div\u0026gt; 3. 评论管理     3.1 使用 ClassName 标签高亮     首先， 使用 useState 管理所选择的排序标签。 hot 作为默认值。\n创建函数 activeClassName 管理标签状态， 与状态类型一致时， 返回 active 类。 所选择的 tab 整体作为参数传入（实际这里只需要类型即可）\nconst [activeType, setActiveType] = useState(\u0026#34;hot\u0026#34;) // 渲染 active 的 tag function activeClassName(tab) { // 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // go 写法  if (tab.type === activeType) { return \u0026#39;nav-item active\u0026#39; } return \u0026#39;nav-item\u0026#39; } 注意: 上述 三元表达式 和 Go 写法 都是正确的。 都是分支流程控制， 使用 JS Switch 语法 - MDN Web Docs 也是可以的。\n其次， 使用 数组Array 的 map 方法生成所有标签。\n\u0026lt;li className=\u0026#34;nav-sort\u0026#34;\u0026gt; {/* 高亮类名： active */} {/* \u0026lt;span className=\u0026#39;nav-item\u0026#39;\u0026gt;最新\u0026lt;/span\u0026gt; */} {/* \u0026lt;span className=\u0026#39;nav-item active\u0026#39;\u0026gt;最火\u0026lt;/span\u0026gt; */} { tabs.map( (tab) =\u0026gt; \u0026lt;span key={tab.type} className={activeClassName(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; ) } \u0026lt;/li\u0026gt; 注意: 在标签中\n 一定不要忘记 key 属性 className 属性是 React 语法， 小驼峰。 多个 className 值合并， 中间使用 空格 分割， 例如 nav-item active。  3.2 评论排序     这里使用了第三方库 lodash 进行数据处理。\n安装 lodash 库\nnpm install lodash 导入 lodash 库。 不太清楚 官方 和 黑马 视频为什么要使用 下划线_ 作为导入后的包名， 但我自己选择使用 lodash。\n// 官方 // var _ require(\u0026#39;lodash\u0026#39;);  // 黑马视频 // import _ from \u0026#39;lodash\u0026#39;;  // 我自己 import lodash from \u0026#39;lodash\u0026#39;; 首先， 定义函数 selectTag 作为选择 排序标签 的事件 回调函数。\n 这里使用了 switch 控制分支流程。 使用 switch 的时候， 一直要注意使用 break 退出， 否则会默认一直下坠，直到遇到 退出控制 或 结束。  这一点与 Go 不同， Go 是用户通过指定 fallthrough 手动下坠的。   由于 评论列表 是通过 useState 管理且 只读不可变， 因此不能直接使用 Array.sort() 进行排序， 使用的 lodash.orderBy 指定排序方法。  // 选择排序芳芳  function selectTab(tab) { setActiveType(tab.type) // tab.type === \u0026#34;hot\u0026#34; ?  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)) :  // setBiliComments(lodash.orderBy(BiliComments, \u0026#39;ctime\u0026#39;, \u0026#39;desc\u0026#39;))  switch (tab.type) { case \u0026#34;hot\u0026#34;: setBiliComments(lodash.orderBy(BiliComments, \u0026#39;like\u0026#39;, \u0026#39;desc\u0026#39;)); // 一定不能忘记这个 break。 否则  // 1. 不再判断 case condition 是否成立  // 2. 继续执行随后的所有 case statement， 直到退出。  break; default: setBiliComments(lodash.orderBy(BiliComments, [\u0026#39;ctime\u0026#39;], [\u0026#39;desc\u0026#39;])); } } 注意：\n lodash.orderBy() 是支持多条件排序的， 需要使用 两个数组 提供 优先级条件字段 以及 排序方式， 一一对应。 如果只有一个字段， 可以省略不使用数组。  最后， 使用 onClick 事件调用函数即可。\n注意 点击事件中 一定 要使用 箭头 函数封装， 以实现点击触发的效果， 否则就直接执行了。\n\u0026lt;span key={tab.type} className={activeClassName(tab)} // 1. 传入变量 // onClick={(item) =\u0026gt; selectTab(item)} onClick={() =\u0026gt; selectTab(tab)} \u0026gt;{tab.text}\u0026lt;/span\u0026gt; 3.3. classNames 类名控制     classnames 是一个第三方库， 用于方便的管理 className。\n如果说之前的两种方式是 手动拼接 类名是 手动挡 的话， 那么使用 classnames 就是自动挡。\n首先 使用 npm 安装\n$ npm install classnames 其次 使用 import 导入\nimport classNames from \u0026#39;classnames\u0026#39;; 最后 根据实际需求，返回 className\n// 渲染 active 的 tag  function activeClassName(tab) { // 1. 三元表达式  // return item.type === activeType ? \u0026#39;nav-item active\u0026#39; : \u0026#39;nav-item\u0026#39;  // 2. Go 写法  // if (tab.type === activeType) {  // return \u0026#39;nav-item active\u0026#39;  // }  // return \u0026#39;nav-item\u0026#39;  // 3. classnames 三方库。 前两种是手动拼接， 容易出错  return classNames(\u0026#34;nav-item\u0026#34;, { active: tab.type === activeType }) } 经过 classNames 对参数的处理后， 会将满足条件的所有参数 拼接 成 字符串。\n  (1) 为 静态 属性， 始终会返回。 (2,3) 为 动态 属性， 根据条件表达式结果返回。 (2) 是 属性名。 (3) 是 布尔表达式， 控制当前属性是否可用。 最终 classNames 返回的就是一个 空格 分割的字符串。  ","description":"1. 安装 sass 支持     npm install sass 2. 评论     使用 useState 管理评论状态\nconst [BiliComments, setBiliComments] = useState(defaultList) 2.1 评论: 使用 Map() 方法渲染     { BiliComments.map( item =\u0026gt; \u0026lt;div className=\u0026#34;content-wrap\u0026#34; key={item.rpid}\u0026gt; // ...  \u0026lt;/div\u0026gt; ) } 2.2. 删除按钮： 条件渲染     {user.uid === item.user.uid \u0026amp;\u0026amp; \u0026lt;span\u0026gt;删除\u0026lt;/span\u0026gt;} 2.3. 删除事件: 点击效果     需要使用一个箭头函数， 实现 点击触发 的效果。"},{"id":3,"href":"/books/react/02-jsx/1-introduce/","title":"01. jsx 的介绍","parent":"2. jsx 基础用法","content":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。\n 可以到 Babel 官网查看编译后的结果\n其他      Babel 官网: https://babeljs.io/repl  ","description":"之前在 /src/App.js 中说到了 className 是 react 语法。 更准确的说是 JSX 语法。\n这是一个带有变量的例子\n// 定义 变量 const message = \u0026#34;this is a message\u0026#34; function App() { // return 中的内容是 jsx 语法  return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; // className 不是 HTML 语法  {message} // 使用变量  \u0026lt;/div\u0026gt; ); } 1. 什么是 jsx     jsx 是 js 的一种扩展语法， 继承了 js 和 xml 的优点。\n 可以使用 HTML 的声明式模版。 可以使用 js 的可编程能力。  由于 jsx 本身不是标准语法。 因此需要使用 Babel 进行编译后， 才能在 浏览器 上运行。 TypeScript同理， 也是需要编译成 js 后才能在浏览器上运行。"},{"id":4,"href":"/books/react/05-hooks/use-state/","title":"01. useState 修改对象并渲染页面","parent":"5. Hooks","content":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。\n1. 修改简单类型     Demo 在 /src/components/hooks/UseStateSimpleType.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateSimpleType() { const [count, setCount] = useState(0) const handler = () =\u0026gt; { const n = count + 1 setCount(n) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;简单类型， number, string\u0026lt;/h3\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 重新渲染: {count - 1}+1 ={count}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 2. 修改对象类型     Demo 在 /src/components/hooks/UseStateObject.jsx\nimport { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) // 使用 setCount, 修改 count 的值，会触发组件的重新渲染。  const handler = () =\u0026gt; { setUser( // 注意：setUser 传递时第一个对象， 因此需要使用 {} 包裹。  { ...user, // 解构语法，展开 user 所有属性  age: user.age + 1 // 修改 age 属性  } ) } return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;修改对象某个属性\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;name: {user.name}, age: {user.age}, address: {user.address}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler}\u0026gt;Handler1 解构语法: \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： user 是通过 const 定义的\n 其 本身不能直接被修改， 即 user={name:x, age:x, address:x}。 但是其 字段可以被修改， 即 user.age=100  import { useState } from \u0026#34;react\u0026#34; export default function UseStateObject() { const [user, setUser] = useState({ \u0026#34;name\u0026#34;: \u0026#34;zhangfei\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;address\u0026#34;: \u0026#34;beijing\u0026#34; }) const handler2 = () =\u0026gt; { user.age = user.age + 1 // setUser(user) // 不会触发重新渲染  setUser({ ...user }) } } 另外， 在使用 setUser 的时候， 可以 直接 传入一个 全新 对象\nconst guanyu = { \u0026#34;name\u0026#34;: \u0026#34;guanyu\u0026#34;, \u0026#34;age\u0026#34;: 22, \u0026#34;address\u0026#34;: \u0026#34;tianjing\u0026#34; } const handlerGuanyu = () =\u0026gt; { setUser(guanyu) } 但是 user 本身不能直接传入， 而需要通过 解构 创建一个 全新 对象\n// setUser 传入 user 不会渲染， 数据会被修改， 但页面不会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); // age 已经修改  setUser(user) // 不会触发重新渲染 } // setUser 通过解构创建一个新对象, 页面会被渲染。 const handler2 = () =\u0026gt; { user.age = user.age + 1 console.log(user); setUser({ // 通过解构创建一个新对象  ...user }) } 使用 setUser(user) 时， 由于传入的是 user ， 虽然其字段发生变化， 但其本身的 指针地址 没有变化， 因此 React 认为没有变化， 不会渲染页面。\n3. 嵌套对象 与 数组     嵌套对象、 数组 与 对象 一样， 都是引用类型。\n因此，在更新渲染时， 都需要传入 新值。 换句话说， 也需要使用 解构语法。\n参考: https://zh-hans.react.dev/reference/react/useState#updating-objects-and-arrays-in-state\n其他      useState - React zhcn  ","description":"React 讲究的是 数据驱动页面。 意思是 当状态数据被修改了，页面内容也会被重新渲染更新。\n如果要上述这个效果， 就需要用到 useState 这个 钩子(Hook)\n 使用 useState 时， 需要先导入。  import { useState } from \u0026#34;react\u0026#34; 使用 const/let 进行结构赋值。 count 和 setCount 是一对 3. useState 创建 状态， 并定义变量的默认值。  count 被称为状态变量，不应该被直接修改， 推荐使用 const 初始化 setCount 是一个函数, 修改 count 的函数。 通过 setCount 修改 count 的值，会触发相关组件的重新渲染。    // const: count 不能被修改 const [count, setCount] = useState(0) // let: count 可以被修改 let [count, setCount] = useState(0) 注意: 使用 let 定义时， count 非只读， 可以直接修改。 但不会触发组件的重新渲染。"},{"id":5,"href":"/books/react/01-setup/01-initialize/","title":"01. 使用 create-react-app 快速搭建开发环境","parent":"1. 准备环境","content":"1. 设置 node.js 国内源     # # https://registry.npm.taobao.org/ yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com 2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令\n// 依赖组建 \u0026quot;dependencies\u0026quot;: { \u0026quot;@testing-library/jest-dom\u0026quot;: \u0026quot;^5.17.0\u0026quot;, \u0026quot;@testing-library/react\u0026quot;: \u0026quot;^13.4.0\u0026quot;, \u0026quot;@testing-library/user-event\u0026quot;: \u0026quot;^13.5.0\u0026quot;, \u0026quot;react\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^18.2.0\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;5.0.1\u0026quot;, \u0026quot;web-vitals\u0026quot;: \u0026quot;^2.1.4\u0026quot; }, // 启动命令 \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, 4. 清理文件     /src 是代码目录， 清理暂时不用的文件， 留下核心\n4.1. 删除文件     删除除了 index.js, App.js 以外的文件。\n此时， 需要在 index.js 和 App.js 中删除引用\ninjex.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; // import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; // import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; App.js, 删除引用文件， 并修改返回内容。\n// import logo from \u0026#39;./logo.svg\u0026#39;; // import \u0026#39;./App.css\u0026#39;;  function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); } export default App; 4.2. 关闭严格模式     在 index.js 中，注释 StrictMode\nconst root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 4.3. 关闭性能监控     在 index.js 中注释 reportWebVitals() 关闭性能监控\n// // If you want to start measuring performance in your app, pass a function // // to log results (for example: reportWebVitals(console.log)) // // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals // reportWebVitals(); 5. 说明     5.1. DOM 初始化     在 index.js 中,\n 通过 React.createRoot 创建了一个 DOM。 并通过 document.getElementById('root') 绑定到了 public/index.html 中的 root 节点上上。  // 这个 root 节点在 public/index.html 中定义。 const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( // \u0026lt;React.StrictMode\u0026gt;  \u0026lt;App /\u0026gt; // \u0026lt;/React.StrictMode\u0026gt; ); 5.2. 组件     在 App.js 中\n// App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html function App() { return ( // return 出去  \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; this is my app \u0026lt;/div\u0026gt; ); }  组件的渲染流程大概如下: App -引入-\u0026gt; index.js -渲染-\u0026gt; index.html 所有组件中都有一个 return 将结果丢给 React. 注意 \u0026lt;className=\u0026quot;App\u0026quot;\u0026gt; 不是 index 语法了， 而是 react 语法了。  其他      中文官网： https://zh-hans.react.dev/learn/start-a-new-react-project B站视频： https://www.bilibili.com/video/BV1ZB4y1Z7o8?p=3\u0026amp;vd_source=0259bb47833cfe6d7c4749c69a49a9d2  ","description":"1. 设置 node.js 国内源     # # https://registry.npm.taobao.org/ yarn config set registry https://registry.npmmirror.com npm config set registry https://registry.npmmirror.com 2. 创建项目     npx create-react-app react-basic  npx 是 node.js 的工具命令， 查找并执行后续包命令。 create-react-app 是 核心包（固定写法）， 用于创建 react 项目 react-basic 是 react 项目名称， 可以自定义。  3. 项目配置     ## 启动命令 npm start ## 编译命令 npm run build # 注意这个 run 用不用都可以 可以在 package.json 中看到核心组建与启动命令"},{"id":6,"href":"/books/react/06-styles/style/","title":"01. 样式的使用","parent":"6. 样式管理","content":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2. css 文件     样式当然可以保存到 css 文件中\n/* demo.css */ .demo { color: green; font-size: 18px; font-style: italic; } 在 JSX 文件中使用 import 导入\nimport \u0026#34;./demo.css\u0026#34; export default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p className=\u0026#34;demo\u0026#34;\u0026gt;2. Import CSS\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } 注意： 这里是 React 规则 的 className， 驼峰 命令\n","description":"源代码在 /src/components/styles/RootStyle.jsx\n1. 行内样式     在标签内使用使用 style={{key:v1, k2:v2}} 实现样式管理。\n\u0026lt;p style={{ color: \u0026#34;red\u0026#34;, fontSize: \u0026#34;18px\u0026#34; }}\u0026gt;1.1. 行内样式\u0026lt;/p\u0026gt;  外层 {}: 开始 React 语法。 {k1:v1, k2:v2}: 是一个 Object 对象。 key 使用 驼峰 规则: font-size =\u0026gt; fontSize  向上面直接写在行内的方式， 管理起来并不清晰。 因此可以将 样式 赋值给一个 变量 保存。\nexport default function RootStyle() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style={style}\u0026gt;1.2. 行内样式2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ) } const style = { color: \u0026#34;blue\u0026#34;, fontSize: \u0026#34;18px\u0026#34; } 2."},{"id":7,"href":"/books/react/04-component/what-is-component/","title":"01. 组件式开发","parent":"4. 组件","content":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     ","description":"1. 组件是什么     组件是用户界面的一部分， 他可以有自己的的逻辑和外观。\n 组件之间 可以互相嵌套 组件 可以多次重复使用   组件化开发， 可以让开发者像搭积木一样构建一个庞大而完整的新系统。\n2. 如何定义组件     "},{"id":8,"href":"/books/react/02-jsx/2-basic-syntax/","title":"02. jsx 的常用用法","parent":"2. jsx 基础用法","content":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 3. 函数调用      在 BasicSyntax 组建外部定义 函数 hello 在内部使用 {hello()} 调用。  注意： 调用函数时，必须要使用 圆括号() 函数才会被执行。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } 4. 方法调用     方法 本质上就是 具有一定限制函数。 因此方法调用与函数调用类似。\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; {/* 字符串方法 */} \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; {/* 创建对象，并调用时间方法 */} \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } // 定义变量 let val = \u0026#39;this is const variable\u0026#39; 5. JS 对象调用     需要注意的是， 这里并不是使用的 双花括号 {{content}}， 而是两个不同意义的花括号。\n 外层 是 jsx 语法的花括号， 表示内部为 js 语法。 内层 是 js 语法的中 style 的定义 style={color:'red'}  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 6. 数学计算     数学计算\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 7. 注释      注释也是使用 花括号{} 开启 JS 语法 然后使用 JS 中的多行注释语法。  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } 其他     完整代码可以在 /src/components/jsx/BasicSyntax.js 中看到\nfunction BasicSyntax() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.2. jsx 基础语法\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;2. 变量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{val}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;3. 函数调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;4. 方法调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{hello().toUpperCase()}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{new Date().getDate()}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;5. js 对象调用\u0026lt;/h3\u0026gt; {/* 注意这里不是不是 双括号 */} {/* 外层括号是 {} 是 jsx 表达式 */} {/* 内层括号是 js 调用, 相当于 style={color:\u0026#39;red\u0026#39;} */} \u0026lt;div style={{ color: \u0026#39;red\u0026#39; }}\u0026gt; this is in div \u0026lt;/div\u0026gt; \u0026lt;h3\u0026gt;6. 数学计算\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{1 + 2}\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;7. 注释\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;这里看不到内容\u0026lt;/p\u0026gt; {/* 这里可以看到 */} \u0026lt;/div\u0026gt; ); } export default BasicSyntax; // 定义变量 let val = \u0026#39;this is const variable\u0026#39; // 定义函数 function hello() { return \u0026#34;Hello React18, from function\u0026#34; } ","description":"在 jsx 中， 可以通过 大括号语法{} 识别 JavaScript 中的表达式。\n常见的包括\n 常量调用 变量调用 函数调用 方法调用 使用 js 对象 等等  1. 常量调用     在 BasicSyntax 内部使用 {'this is const string'}\n// BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;1. 常量调用\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{\u0026#39;this is const string\u0026#39;}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 2. 变量调用      在 BasicSyntax 组建外部定义 变量 val。 在内部使用 {val} 调用  // BasicSyntax 基础语法组建 function BasicSyntax() { return ( \u0026lt;div className=\u0026#34;BasicSyntax\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;2."},{"id":9,"href":"/books/react/05-hooks/use-immer/","title":"02. useImmer","parent":"5. Hooks","content":"useImmer 是 useState 的 加强版。\n","description":"useImmer 是 useState 的 加强版。"},{"id":10,"href":"/books/react/04-component/define-component/","title":"02. 如何定义组件","parent":"4. 组件","content":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。\n在 /src/components/component/ClassComponent.js 中\n 必须要 import React 创建的类要 继承 自 React.Component 必须存在 类方法 render。 render 最终返回一对 标签， 与 函数式组件 一样了。  // 必须要引入 React import React from \u0026#34;react\u0026#34;; // 1. 创建类式组件 class MyClassComponent extends React.Component { // 1. 构建函数 「不是必须存在」  // 2. render 必须存在  // render 是放在哪里的？ -- MyClassComponent 类 的原型对象上， 供实例使用。  // render 中的 this 是谁？ -- MyClassComponent 的实例对象。  render() { console.log(this); return ( \u0026lt;button\u0026gt;class component\u0026lt;/button\u0026gt; ) } } export default MyClassComponent; 2. 组件的导出     同一文件中的组件是可以互相引用的。 如果允许组件被外部引用， 则需要使用 export 关键字。\n 每个文件 最多只有一个 export default。 最少可以没有， 及没有默认导出。 参考  FunctionComponent MyClassComponenet   如果有其他组件还需要导出， 则可以在定义的所在位置使用 export 关键字  参考 ArrowFuncComponenet    3. 组件的引用     在 /src/components/component/RootComponent.js 中\n组件的使用， 与 标准HTML标签 的使用方式一样。\n 自闭和标签 成对标签  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; import FunctionButtion, { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; function RootComponent() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;4. 组件的定义和使用\u0026lt;/h2\u0026gt; {/* 组件的使用 {/* 1. 自闭和标签 */} \u0026lt;FunctionButtion /\u0026gt; {/* 2. 成对标签 */} \u0026lt;ArrowFuncButtion\u0026gt;\u0026lt;/ArrowFuncButtion\u0026gt; {/* 引用外部文件组件 */} \u0026lt;MyClassComponent /\u0026gt; \u0026lt;/div\u0026gt; ) } 在使用标签之前， 需要确定标签是否被引用到本文件。\n  如果 当前组件(RootComponenet) 与 被引用组件 在同一个文件中， 不需要使用 import\n  如果 被引用组件 是 默认导出组件， 则直接 import\n  import FunctionButtion from \u0026#34;./FuncComponent\u0026#34;; 如果 被引用组件 是 非默认导出组件， 则需要使用 花括号{} 包裹引用组件名。  import { ArrowFuncButtion } from \u0026#34;./FuncComponent\u0026#34;; 如果一个文件有多个组件被引用， 可以合并写在一行  import FunctionButtion, { ArrowFuncButtion, OtherButton } from \u0026#34;./FuncComponent\u0026#34;; 默认导出组件名 可以与其 所在文件名 不同。  import MyClassComponent from \u0026#34;./ClassComponent\u0026#34; ","description":"组件的定义方式有两种。\n 函数式组件： 最常用 类式组件  组件名通常使用 大驼峰 命名方式， 即 首字母大写的驼峰\n例如， MyButton, UserInfoDisplay\n1. 组件的定义     1.1. 函数式组件     在 /src/components/component/FuncComponent.js 中\nfunction FunctionButtion() { return ( \u0026lt;button\u0026gt;function buttion\u0026lt;/button\u0026gt; ) } export default FunctionButtion; 1.2. 箭头函数式组件     箭头函数也是函数， 所以和上面 function 定义没什么区别。 也在 /src/components/component/FuncComponent.js 中\nexport const ArrowFuncButtion = () =\u0026gt; { return ( \u0026lt;button\u0026gt;arrow func button\u0026lt;/button\u0026gt; ) } 1.3. 类式组件     这个有有点特别了， 在 React 18 中， 已经不怎么用了。"},{"id":11,"href":"/books/react/02-jsx/3-list-render/","title":"03. 列表与字典渲染","parent":"2. jsx 基础用法","content":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，\n 使用 列表的 map 方法。 循环的是 \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; 标签， 就在循环中返回该标签。 标签属性 一定要使用 key。 且 key 的值 必须 是 唯一的 unique。  key 是 React 在进行渲染的时候做 diff 算法的标识。 如果不用， 在列表删除的时候就会出现数据偏差。    2. 不规范的省略写法     最常见的不规范写法， 就是省略了 唯一key\n(item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 打开控制台， 可以看到 警告 如下：\nWarning: Each child in a list should have a unique \u0026quot;key\u0026quot; prop.  function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;箭头函数 省略版： 有括号\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; { list.map((item) =\u0026gt; (\u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;)) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] 除此之外， 还有一种更省略的写法就是： 省略 圆括号， 这是 JS 的语法特性。\nlist.map(item =\u0026gt; \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt;) 这两种都不是什么好的写法， 不用过多关注， 但是要知道可以这么写。\n其他:      React 的列表渲染 - 黑马 JS Array Usage  ","description":"代码在 /src/components/jsx/ListRender.js 中\n列表默认情况是这样的\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;liubei\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;guanyu\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;zhangfei\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 1. 标准版的渲染     const list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;] function ListRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;2.3. 循环渲染\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; list = [\u0026#39;liubei\u0026#39;, \u0026#39;guanyu\u0026#39;, \u0026#39;zhangfei\u0026#39;]\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;箭头函数， 完整版。 带 key \u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; // (1) 保留外城的 ul  { list.map((item, index) =\u0026gt; { // (2) 循环什么就返回什么。  // (3) key 是 React 渲染的唯一表示  return \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt; }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } 当我们要进行 列表渲染 的时候，"},{"id":12,"href":"/books/react/02-jsx/4-conditional-render/","title":"04. 条件渲染","parent":"2. jsx 基础用法","content":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序\nLine 10:16: Unexpected mix of '\u0026amp;\u0026amp;' and '||'. Use parentheses to clarify the intended order of operations 因此我们可以通过 圆括号 进行归类， 注意括号未知。\n{(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} {isLogin \u0026amp;\u0026amp; (\u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;)} 2. 三目运算符     三目运算符 具有固定格式： condition? yes : no ， 注意分隔符。\nfunction ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;2. 三目运算符 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin ? Login : Logout\u0026lt;/p\u0026gt; {isLogin ? \u0026lt;Login /\u0026gt; : \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false; 3. 分支条件语句     分支条件语句\n 在 statement 中可以实现更复杂的操作 可以返回更多的 条件结果。  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;3. 分支函数\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;if (isLogin); return Login; else return Logout; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{Condition()}\u0026lt;/p\u0026gt; \u0026lt;/div \u0026gt; ) } const isLogin = false; function Condition() { if (isLogin) { {/* 其他操作 */} console.log(isLogin) return \u0026lt;Login /\u0026gt; } else { return \u0026lt;Logout /\u0026gt; } } 注意 Condition 由于 只有两个条件 结果， 非此即彼。因此函数还可以写成 以下形式 不用 else。\nfunction Condition() { if (isLogin) { return \u0026lt;Login /\u0026gt; } return \u0026lt;Logout /\u0026gt; } 其他:      如何渲染布尔值: String(bool1) jsx 简单条件渲染 jsx 复杂条件渲染  ","description":"React 根据条件运算返回的不同结果进行结果渲染， 主要分为以下几种\n 逻辑判断： \u0026amp;\u0026amp;, ||, ! 三目运算符: condition? yes : no 分支语句： if-else, switch  1. 逻辑运算符     逻辑运算符：\n \u0026amp;\u0026amp; 且 || 或 ! 非  function ConditionalRender() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;04. 条件渲染: isLogin={String(isLogin)}\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;1. 逻辑语句\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login \u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;} \u0026lt;p\u0026gt;isLogin || Logout\u0026lt;/p\u0026gt; {isLogin || \u0026lt;Logout /\u0026gt;} \u0026lt;p\u0026gt;isLogin \u0026amp;\u0026amp; Login || Logout\u0026lt;/p\u0026gt; {isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt; || \u0026lt;Logout /\u0026gt;} {(isLogin \u0026amp;\u0026amp; \u0026lt;Login /\u0026gt;) || \u0026lt;Logout /\u0026gt;} \u0026lt;/div \u0026gt; ) } const isLogin = false;  条件语句 必须要在最前面。 \u0026amp;\u0026amp; 和 || 可以单独使用； 也可以一起使用， 一起使用时效果类似 三目运算符。  但是 React 并不推荐这么做， 如果这样做了会给予提示： 混合使用 \u0026amp;\u0026amp; 和 ||。 请用 圆括号 指定执行顺序"},{"id":13,"href":"/books/react/03-event/on-click/","title":"1. OnClick 点击事件","parent":"3. 事件绑定","content":" 事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意\n 需要使用 花括号{} 开启 jsx 执行函数(表达式)。 handler 函数 不需要被执行， 即没有跟 园括号。  function EventOnClick() { let count = 0 // 不接受参数  // 变量形式  const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 2. 接收事件参数     在事件触发是， React 是 默认 传递 事件参数 的，\n handler 函数只需要准备好 形参 接收即可。 在调用时 不需要 额外手工参数 实参。  这一点与 传递自定义参数 不同， 可以对比接下来的 第 3 点。\nfunction EventOnClick() { let count = 0 // 接收事件  // 函数形式  function handler2(event) { console.log(event) // count = count + 2  } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={handler2}\u0026gt;button e\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 3. 接收自定义参数     其实就是在普通的 handler 函数的基础上， 在 调用 的时候使用 箭头 函数封装了一次。\n// 调用 onClick={() =\u0026gt; { handler3(count) }} 这里你可以看到有连个 花括号\n 外层： 是启用 jsx 的语法。 内层： 箭头函数的函数体边界。 其实这里也可以省略成以下形式  // 调用 onClick={() =\u0026gt; handler3(count) } 完整代码如下\nfunction EventOnClick() { let count = 0 // 接受参数  function handler3(n) { console.log(n); count = count + 3 } // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 注意这里是箭头函数 */} \u0026lt;button onClick={() =\u0026gt; { handler3(count) }}\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; handler3(count) }\u0026gt;button(+3)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 4. 接收自定义参数与事件参数     同时接收 自定义参数 和 事件参数： 其实也很简单， 就是在上一个的技术上， 通过 箭头 函数获取了 事件参数， 再传给了 handler 函数。 可以说是 2,3 的结合体。\n注意： 在传递参数时， 需要注意参数的位置。\nfunction EventOnClick() { let count = 0 // 接受参数和事件  const handler4 = (n, event) =\u0026gt; { console.log(n, event); count = count + 4 } return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count={count}\u0026lt;/p\u0026gt; {/* 1. 箭头函数， 2 参数位置 */} \u0026lt;button onClick={(event) =\u0026gt; { handler4(count, event) }}\u0026gt;button(+4,e)\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } export default EventOnClick; 其他      Event handlers - React Learn  ","description":"事件名称统一为 onXXXX Hanlder 函数支持多种方式定义， 变量形式 与 函数形式  // 不接受参数 // 变量形式 const handler1 = () =\u0026gt; { console.log(count); count = count + 1 } // 接收事件 // 函数形式 function handler2(event) { console.log(event) // count = count + 2 } 这里是是 onClick 点击事件。\n1. 不接受参数     这种最简单， 只需要在 标签 中的 属性 中， 使用 onClick 事件时 指定 调用 handler 函数 即可。\n\u0026lt;button onClick={handler1}\u0026gt;button +1\u0026lt;/button\u0026gt; 如上， 是在 button 中接收了的 onClick 事件。 注意"},{"id":14,"href":"/books/react/01-setup/","title":"1. 准备环境","parent":"","content":"","description":""},{"id":15,"href":"/books/react/02-jsx/","title":"2. jsx 基础用法","parent":"","content":"","description":""},{"id":16,"href":"/books/react/03-event/on-change/","title":"2. onChange 变更事件实现数据绑定","parent":"3. 事件绑定","content":" 在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2. onChange(e) 实现数据从 UI 到 state 的单向绑定 */} \u0026lt;input value={username} onChange={(e) =\u0026gt; setUsername(e.target.value)} /\u0026gt; \u0026lt;span\u0026gt;{username}\u0026lt;/span\u0026gt; \u0026lt;/div \u0026gt; ) } ","description":"在 /src/components/event/EventOnChange.js 中实现了 数据的双向绑定。 即\n 使用 useState 管理变量 username 的状态 使用 {username} 实现数据 从 state 到 UI 的单向绑定。 使用 onChange 捕捉控件的变化事件。 随后通过 箭头函数 获取 当前事件目标的值(e.target.value) 并通过 setUsername 保存数据， 从而数据 从 UI 到 state 的单向绑定。 当数据更新到 state 后， React 又刷新了页面。  // Path: src/components/event/EventOnClick.js  import { useState } from \u0026#34;react\u0026#34; export default function EventOnChange() { const [username, setUsername] = useState(\u0026#34;zhangsan\u0026#34;) return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;OnChange 事件实现数据双向绑定\u0026lt;/h2\u0026gt; {/* 1. {username} 实现数据从 state 到 UI 的单向绑定 2."},{"id":17,"href":"/books/react/03-event/","title":"3. 事件绑定","parent":"","content":"","description":""},{"id":18,"href":"/books/react/04-component/","title":"4. 组件","parent":"","content":"","description":""},{"id":19,"href":"/books/react/05-hooks/","title":"5. Hooks","parent":"","content":"","description":""},{"id":20,"href":"/books/react/06-styles/","title":"6. 样式管理","parent":"","content":"","description":""},{"id":21,"href":"/books/react/98-library/","title":"98. 三方库","parent":"","content":"","description":""},{"id":22,"href":"/books/react/99-demos/","title":"99. 项目案例","parent":"","content":"","description":""},{"id":23,"href":"/books/react/98-library/chassnames/","title":"classnames 使用对象管理 className","parent":"98. 三方库","content":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; ","description":"    项目地址: https://github.com/JedWatson/classnames\n安装方式     npm install classnames Demo     import classNames from \u0026#39;classnames\u0026#39;; classNames(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames(\u0026#39;foo\u0026#39;, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: true }); // =\u0026gt; \u0026#39;foo-bar\u0026#39; classNames({ \u0026#39;foo-bar\u0026#39;: false }); // =\u0026gt; \u0026#39;\u0026#39; classNames({ foo: true }, { bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39; classNames({ foo: true, bar: true }); // =\u0026gt; \u0026#39;foo bar\u0026#39;  // lots of arguments of various types classNames(\u0026#39;foo\u0026#39;, { bar: true, duck: false }, \u0026#39;baz\u0026#39;, { quux: true }); // =\u0026gt; \u0026#39;foo bar baz quux\u0026#39;  // other falsy values are just ignored classNames(null, false, \u0026#39;bar\u0026#39;, undefined, 0, { baz: null }, \u0026#39;\u0026#39;); // =\u0026gt; \u0026#39;bar\u0026#39; "},{"id":24,"href":"/books/react/98-library/lodash/","title":"lodash 工具库","parent":"98. 三方库","content":"","description":""},{"id":25,"href":"/books/react/tags/","title":"Tags","parent":"","content":"","description":""},{"id":26,"href":"/books/react/01-setup/sass/","title":"添加 sass 支持","parent":"1. 准备环境","content":"npm install sass ","description":"npm install sass "}]
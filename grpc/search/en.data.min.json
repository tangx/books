[{"id":0,"href":"/books/grpc-go/","title":"","parent":"","content":"gRPC     ","description":"gRPC     "},{"id":1,"href":"/books/grpc-go/grpc-go/01-prepare-install/","title":"1. setup","parent":"gRPC-Go","content":"安装工具     ## protoc curl -LO https://github.com/protocolbuffers/protobuf/releases/wnload/v3.19.0/protoc-3.19.0-osx-x86_64.zip unzip -q protoc-3.19.0-osx-x86_64.zip -d protoc \u0026amp;\u0026amp; sudo mv protoc /r/local/bin export PROTOC_BIN=/usr/local/protoc/bin export PATH=\u0026#34;$PROTOC_BIN:$PATH\u0026#34; ## go plugins go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 ","description":"安装工具     ## protoc curl -LO https://github.com/protocolbuffers/protobuf/releases/wnload/v3.19.0/protoc-3.19.0-osx-x86_64.zip unzip -q protoc-3.19.0-osx-x86_64.zip -d protoc \u0026amp;\u0026amp; sudo mv protoc /r/local/bin export PROTOC_BIN=/usr/local/protoc/bin export PATH=\u0026#34;$PROTOC_BIN:$PATH\u0026#34; ## go plugins go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1 "},{"id":2,"href":"/books/grpc-go/grpc-go/02-protobuf-introduce/","title":"2. 介绍","parent":"gRPC-Go","content":"demo     layout     . └── pkg └── services // proto 文件及生成的相关接口文件  ├── prod.pb.go // protoc 生成  ├── prod_grpc.pb.go // protoc 生成  ├── prod.proto // 自建 proto 生成的接口文件将成为 server 和 client 都会依赖的 库文件 。 这部分文件应该单独管理， 或通过 CI 在公司内部的公共库进行发布与管理。\nproto     // 语法版本， 支持 proto2, proto3 // 默认为 proto2 syntax=\u0026#34;proto3\u0026#34;;// 在 go module 模式下 // 需要使用 go_package 生成文件的 package 绝对路径 option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;// package 可选字段 // 1. 在 grpc 中注册的时候， 指定前置路径， 避免重名服务冲突。 // 2. 在 go 中被默认用作包名（没什么用）， 因为 go_package 需要指定 package grpc_go_demo.prod;// 定义消息体 message ProdRequest { int32 prod_id=1; // 传入商品ID }message ProdResponse{ int32 prod_stock=1; // 商品库存 }// 定义服务 service ProdService { rpc GetProdStock(ProdRequest) returns (ProdResponse);}proto3 语法     // 语法版本， 支持 proto2, proto3 // 默认为 proto2 syntax=\u0026#34;proto3\u0026#34;;// 在 go module 模式下 // 需要使用 go_package 生成文件的 package 绝对路径 option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;// package 可选字段 // 1. 在 grpc 中注册的时候， 指定前置路径， 避免重名服务冲突。 // 2. 在 go 中被默认用作包名（没什么用）， 因为 go_package 需要指定 package grpc_go_demo.prod;syntax     指定语法规则版本\n 默认为 proto2。 虽然有默认值， 但如果使用 proto2 也建议 显式声明 syntax=\u0026quot;proto2\u0026quot;。 支持 proto3, proto2。  package     包名， 可选字段。\n 在 grpc 服务器中注册的时候作为前置路径，避免多个重名服务产生冲突。 在 go 中， 此包名将被编译成 go 中的 package name。 但如果使用 option go_package 则以后者为准。   https://developers.google.com/protocol-buffers/docs/proto3?hl=en#packages\n 如编译后的结果。可以看到在 gprc 服务器中注册的路径为 /grpc_go_demo.prod.ProdService/GetProdStock\nfunc (c *prodServiceClient) GetProdStock(ctx context.Context, in *ProdRequest, opts ...grpc.CallOption) (*ProdResponse, error) { out := new(ProdResponse) err := c.cc.Invoke(ctx, \u0026#34;/grpc_go_demo.prod.ProdService/GetProdStock\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } option go_package     可选项。 在 go 中指明包路径。\n 如果不声明， 必须在使用 protoc 的时候， 使用 M flag 指定。 如果声明了， 但在 protoc 使用了 M flag。 以 flag 指定的值为准。 使用了 option go_package 选项， package name 将不在作为默认编译的 go 包名。  编译时使用 M flag\nprotoc --proto_path=src \\  --go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\  --go_opt=Mprotos/bar.proto=example.com/project/protos/foo \\  protos/buzz.proto protos/bar.proto  https://developers.google.com/protocol-buffers/docs/reference/go-generated#package\n 消息体定义     // 定义消息体 message ProdRequest { int32 prod_id=1; // 传入商品ID }在 protobuf 中， message 定义的是 grpc server 和 client 端的的消息结构信息。 在编译成 go 后， 会生成的对应的 struct 和 方法。\n上述 定义中:\n message ProdRequest  message : 关键字， 定义对象类型 ProdRequest: 对象名称   int32 prod_id=1;  int32: 字段类型 prod_id: 字段名称 1: 字段在消息体中的位置， 而非字段值    使用 protoc --go_out=. 命令及参数可以将 message 部分编译成对应的 go 文件。 文件名为 prod.pb.go， 同名 prod ， 以 .pb.go 结尾。\nprotoc --go_out=. --go_opt=paths=source_relative \\ \tpkg/services/prod.proto 在编译结果中， 和我们业务息息相关的主要是一下部分。\ntype ProdRequest struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields ProdId int32 `protobuf:\u0026#34;varint,1,opt,name=prod_id,json=prodId,proto3\u0026#34; json:\u0026#34;prod_id,omitempty\u0026#34;` // 传入商品ID } func (x *ProdRequest) GetProdId() int32 { if x != nil { return x.ProdId } return 0 }  message 对象被编译成了 同名 的 struct 对象， 里面包含一些 proto 的默认字段， 已经我们定义的 PordId 字段。 同时为我们生成了获取 ProdId 相关方法 GetProdId()  service 定义     service 定义 grpc 服务， 所有需要使用的服务， 都需要注册到 grpc 服务器 中。 这个后面再说。\n// 定义服务 service ProdService { rpc GetProdStock(ProdRequest) returns (ProdResponse);} service ProdService:  service: 关键字， 定义一个服务 ProdService: 用户自定义的服务名。   rpc GetProdStock(ProdRequest) returns (ProdResponse);  rpc: 定义传递方式 GetbProdStock(ProdRequest): 定义服务的方法名称， 及传递的消息体参数。 returns (ProdResponse): 定义服务的返回消息体。    使用 protoc --go-grpc_out. 命名及参数可以将 service 部分编译成 go 文件。 文件名为 prod_grpc.pb.go， 文件同名 prod, 以 _grpc.pb.go 结尾。\nprotoc --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ \tpkg/services/prod.proto service 对象编译后， 为 server 和 client 都生成了各自的 接口定义。 文件中还包含了一个完整的 demo。\ntype ProdServiceClient interface { GetProdStock(ctx context.Context, in *ProdRequest, opts ...grpc.CallOption) (*ProdResponse, error) } type ProdServiceServer interface { GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error) mustEmbedUnimplementedProdServiceServer() }  所有生成的文件都不要去改， 否则重新编译之后， 所有的更改都会丢失。\n 之后， 我们就可以使用生成的结构体和对象构建我们的自己的服务和业务逻辑。\n","description":"demo     layout     . └── pkg └── services // proto 文件及生成的相关接口文件  ├── prod.pb.go // protoc 生成  ├── prod_grpc.pb.go // protoc 生成  ├── prod.proto // 自建 proto 生成的接口文件将成为 server 和 client 都会依赖的 库文件 。 这部分文件应该单独管理， 或通过 CI 在公司内部的公共库进行发布与管理。\nproto     // 语法版本， 支持 proto2, proto3 // 默认为 proto2 syntax=\u0026#34;proto3\u0026#34;;// 在 go module 模式下 // 需要使用 go_package 生成文件的 package 绝对路径 option go_package = \u0026#34;github."},{"id":3,"href":"/books/grpc-go/grpc-go/03-launch-a-server/","title":"3. 创建 grpc 服务端","parent":"gRPC-Go","content":"创建第一个 grpc 服务     . ├── cmd │ ├── client // 客户端 │ │ └── main.go │ └── server // 服务端 │ └── main.go └── pkg └── services // proto 文件及生成的相关接口文件  └── prod_services.go // 自己新建 实现自己的 prod 服务     自建文件 prod_service.go, 要在此文件中实现自己的 ProdService 逻辑。\nprotoc 生成的 server 端接口如下\ntype ProdServiceServer interface { GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error) mustEmbedUnimplementedProdServiceServer() } 有了接口， 创建 struct 对象来不手到擒来？\ntype ProdService struct { } func (prod *ProdService) GetProdStock(ctx context.Context, in *ProdRequest) (*ProdResponse, error) { // 一个简单的模拟逻辑， 打印收到的传入参数 \tlog.Printf(\u0026#34;request in, search prod_id = %d\\n\u0026#34;, in.GetProdId()) // 创建一个固定返回， 模拟结果 \tresp := \u0026amp;ProdResponse{ ProdStock: 20, } // 返回应答结果结果 \treturn resp, nil } // 什么都需不要做， 单纯的就是满足接口 func (prod *ProdService) mustEmbedUnimplementedProdServiceServer() { } 业务代码实现的很简单， 都在注释里面了。\n创建 grpc server     创建 server 启动文件 server/main.go\n 注意: server 端需要依赖之前通过 protoc 生成的 package 包。\n package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; ) const ( port = \u0026#34;:8089\u0026#34; ) func main() { // 创建 grpc 服务器 \ts := grpc.NewServer() // 注册 grpc 的服务 \tservices.RegisterProdServiceServer(s, \u0026amp;services.ProdService{}) // 创建 socket ，监听端口 \tlis, err := net.Listen(\u0026#34;tcp\u0026#34;, port) if err != nil { log.Fatalf(\u0026#34;failed to listen: %v\\n\u0026#34;, err) } log.Printf(\u0026#34;server listening at %v\\n\u0026#34;, lis.Addr()) // 启动 grpc 服务 \tif err := s.Serve(lis); err != nil { log.Fatalf(\u0026#34;failed to serve: %v\\n\u0026#34;, err) } } 几行代码， 很简单， 注释都写的很清楚了。\n注册 prod 服务     需要额外注意的是 向 grpcServer 注册 prodService 这部分。\nservices.RegisterProdServiceServer(s, \u0026amp;services.ProdService{})  services.RegisterProdServiceServer : 这个注册函数是 protoc 生成的，没有太多注意的地方。 services.ProdService{}: 是我们自己创建的对象， 接口一定要实现完整。 在开发的时候， 可以实现接口检查语法。 当然， 实现不然完整， service 也不会注册成功  // 接口检查 var _ ProdServiceServer = \u0026amp;ProdService{}s 创建 client     创建客户端 client/main.go。\n 注意: client 也需要引用之前 protoc 生成的 package 包。\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; ) func main() { // 创建一个 grpc 连接 \tconn, err := grpc.Dial(\u0026#34;:8089\u0026#34;, grpc.WithInsecure()) if err != nil { log.Fatalf(\u0026#34;dail rpc server failed: %v\\n\u0026#34;, err) } defer conn.Close() // 创建一个 prod service 客户端 \tclient := services.NewProdServiceClient(conn) ctx := context.Background() // 构造一个固定的请求参数s \tin := \u0026amp;services.ProdRequest{ ProdId: 12, } // 发起请求，拿到请求结果 \tret, err := client.GetProdStock(ctx, in) if err != nil { log.Fatalf(\u0026#34;client get prod stock failed: %v\\n\u0026#34;, err) } fmt.Println(ret.ProdStock) } 代码很简单， 都在注释里面了。\n无证书启动 WithInsecure     需要注意的是, 由于现在还没使用 tls 证书， 因此在启动的时候， 需要使用参数 grpc.WithInsecure() 。\nconn, err := grpc.Dial(\u0026#34;:8089\u0026#34;, grpc.WithInsecure()) ","description":"创建第一个 grpc 服务     . ├── cmd │ ├── client // 客户端 │ │ └── main.go │ └── server // 服务端 │ └── main.go └── pkg └── services // proto 文件及生成的相关接口文件  └── prod_services.go // 自己新建 实现自己的 prod 服务     自建文件 prod_service.go, 要在此文件中实现自己的 ProdService 逻辑。\nprotoc 生成的 server 端接口如下\ntype ProdServiceServer interface { GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error) mustEmbedUnimplementedProdServiceServer() } 有了接口， 创建 struct 对象来不手到擒来？\ntype ProdService struct { } func (prod *ProdService) GetProdStock(ctx context."},{"id":4,"href":"/books/grpc-go/grpc-go/08-import-thirdparty-proto/","title":"4. import 三方依赖","parent":"gRPC-Go","content":"引用第三方包     在引用第三方包的时候， 不用将其放在自己的工程目录下。 只需要在编译的时候， 只需要使用 --proto_path 添加搜索路径即可正常导入。\n例如， 在 order_model.proto 中， 使用了 google 的 timestamp， 文件定义如下:\nimport \u0026#34;google/protobuf/timestamp.proto\u0026#34;; // 引入文件相对路径 message OrderMain { // ...省略  google.protobuf.Timestamp timestamp=5; // 包名.类型名 }import 的导入路径     下载安装 protoc 时， 压缩包中包含了 goolge 的诸多 proto 文件。 根据文件路径添加 --proto_path=/usr/local/protoc/include/\n{ \u0026quot;protoc\u0026quot;: { \u0026quot;path\u0026quot;:\u0026quot;/usr/local/protoc/bin/protoc\u0026quot;, \u0026quot;options\u0026quot;: [ \u0026quot;--proto_path=${workspaceRoot}/\u0026quot;, // 工程目录 \u0026quot;--proto_path=/usr/local/protoc/include/\u0026quot;, // google protos ] } } 就可以在直接在工程 proto 文件中使用\nimport \u0026#34;google/protobuf/timestamp.proto\u0026#34;;message 的字段类型     与 直接 引用 相同包 定义的类型不同。\nimport \u0026#34;protos/services/prod.proto\u0026#34;;message ProdResponseList { repeated ProdResponse prods=1;}使用了第三方包需要在 类型字段 加上 包的 package name 。 这个名字需要在 源 proto 文件中 去查找。\n根据 google/protobuf/timestamp.proto 的如下定义\n// google/protobuf/timestamp.proto syntax = \u0026#34;proto3\u0026#34;;package google.protobuf; // 包名 message Timestamp { // Timestamp 的定义  int64 seconds = 1; int32 nanos = 2;}在使用 Timestamp 时， 补全完整包名定义。 如下\nmessage OrderMain{ google.protobuf.Timestamp timestamp=5;}","description":"引用第三方包     在引用第三方包的时候， 不用将其放在自己的工程目录下。 只需要在编译的时候， 只需要使用 --proto_path 添加搜索路径即可正常导入。\n例如， 在 order_model.proto 中， 使用了 google 的 timestamp， 文件定义如下:\nimport \u0026#34;google/protobuf/timestamp.proto\u0026#34;; // 引入文件相对路径 message OrderMain { // ...省略  google.protobuf.Timestamp timestamp=5; // 包名.类型名 }import 的导入路径     下载安装 protoc 时， 压缩包中包含了 goolge 的诸多 proto 文件。 根据文件路径添加 --proto_path=/usr/local/protoc/include/\n{ \u0026quot;protoc\u0026quot;: { \u0026quot;path\u0026quot;:\u0026quot;/usr/local/protoc/bin/protoc\u0026quot;, \u0026quot;options\u0026quot;: [ \u0026quot;--proto_path=${workspaceRoot}/\u0026quot;, // 工程目录 \u0026quot;--proto_path=/usr/local/protoc/include/\u0026quot;, // google protos ] } } 就可以在直接在工程 proto 文件中使用\nimport \u0026#34;google/protobuf/timestamp."},{"id":5,"href":"/books/grpc-go/grpc-go/04-import-proto-file/","title":"4. import 依赖","parent":"gRPC-Go","content":"使用 import 引入其他包     在使用 grpc 的时候，不可避免的会用到 其他 proto 文件。 这时就需要在 proto 文件中使用 import 语法。\n如果不了解 import 的路径规则， 那么可能出现以下错误。\nImport \u0026quot;model.proto\u0026quot; was not found or had errors. 使用 import     创建 model.proto 定义一个 ProdModel 的消息体(message)\n// model.proto syntax=\u0026#34;proto3\u0026#34;;option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;message ProdModel { int32 prod_id=1; string prod_name=2; float prod_price=3;}在 prod.proto 文件中使用 import 引入 model.proto\n// prod.proto syntax=\u0026#34;proto3\u0026#34;;option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;package grpc_go_demo.prod;// 引入文件 import \u0026#34;pkg/services/model.proto\u0026#34;;service ProdService { rpc GetProdStock(ProdRequest) returns (ProdResponse); rpc GetProdModel(ProdRequest) returns (ProdModel); // 添加新接口 }虽然 prod.proto 和 model.proto 在同一个目录下， 这里使用的路径是 pkg/services/model.proto。\n 注意: proto 中， 在 源文件 prod.proto 中使用 import 引入 目标文件 model.proto 的路径 并不是 源文件开始的相对路径。\n 在 proto 中 import 使用的目标文件路径， 是根据执行 protoc 的参数 --proto_path 确定的。\n 该默认值为 --proto_path=.， 即当前路径。 --proto_path 可以有多个， 即在多个文件夹中搜索。  可以类比为 linux 中的 PATH 环境变量 PATH=$path1:$path2:$path3。    当前在 Makefile 中的编译命令如下。 因为 Makefile 是在 项目根目录 ， 与 pkg 同一层。\nprotoc --go_out=. --go_opt=paths=source_relative \\ \tpkg/services/proto.proto 举个例子， 当前的目录结构如下。\n. ├── // PROTOC: import \u0026#34;pkg/services/model.proto\u0026#34; └── pkg ├── // PROTOC: import \u0026#34;services/model.proto\u0026#34;  └── services ├── // PROTOC: import \u0026#34;model.proto\u0026#34;  ├── model.proto ├── prod.proto PROTOC 为执行 protoc 命令所在的目录。 在不同的目录执行命令， 所对应的 import 路径如注释标注。\n 注意: 虽然可以使用 --proto_path 添加多个搜索路径， 但还是建议使用 基于项目根目录的相对路径 。 不仅文件路径清晰， 而且编译指定命令位置很固定，方便统一管理。\n server 和 client 实现接口     解决完成 import 问题之后， 重新编译。 server 和 client 的接口中都增加新方法。\ntype ProdServiceServer interface { GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error) GetProdModel(context.Context, *ProdRequest) (*ProdModel, error) mustEmbedUnimplementedProdServiceServer() } type ProdServiceClient interface { GetProdStock(ctx context.Context, in *ProdRequest, opts ...grpc.CallOption) (*ProdResponse, error) GetProdModel(ctx context.Context, in *ProdRequest, opts ...grpc.CallOption) (*ProdModel, error) } server 实现新方法     接口更新后， 之前在 prod_service.go 实现的 ProdService 也出现了异常。 补齐缺少的方法\nfunc (prod *ProdService) GetProdModel(context.Context, *ProdRequest) (*ProdModel, error) { resp := \u0026amp;ProdModel{ ProdId: 100, ProdName: \u0026#34;泡腾片\u0026#34;, ProdPrice: 32.5, } return resp, nil } client 调用新方法     client 就更简单了， 直接调用新方法\nfunc main() { // ...省略 \tret, err := client.GetProdStock(ctx, in) if err != nil { log.Fatalf(\u0026#34;client get prod stock failed: %v\\n\u0026#34;, err) } fmt.Println(ret.ProdStock) // 调用方法 \tret2, _ := client.GetProdModel(ctx, in) fmt.Printf(\u0026#34;%+v\\n\u0026#34;, ret2) } 使用 vscode 插件帮助管理     在 vscode 中开发， 可以安装插件 vscode-proto3 协助管理。\n在项目根目录创建 .vscode/settings.json 文件， 配置 protoc 的参数。 如此依赖 vscode 可以帮助检测路径是否合法， 以及其他。\n{ \u0026quot;protoc\u0026quot;: { // 指定 protoc 路径 // \u0026quot;path\u0026quot;:\u0026quot;/usr/local/protoc/bin/protoc\u0026quot;, // 保存后立即编译 \u0026quot;compile_on_save\u0026quot;: false, \u0026quot;options\u0026quot;: [ // 指定多个路径 \u0026quot;--proto_path=.\u0026quot;, // 默认 \u0026quot;--proto_path=${workspaceRoot}/\u0026quot;, \u0026quot;--proto_path=${workspaceRoot}/pkg/services/\u0026quot;, // 使用后，可以直接 import model.proto // 其他编译命令， 和之前 makefile 中一样。 \u0026quot;--go_out=.\u0026quot;, \u0026quot;--go_opt=paths=source_relative\u0026quot;, \u0026quot;--go-grpc_out=.\u0026quot;, \u0026quot;--go-grpc_opt=paths=source_relative\u0026quot;, ] } } 其他文档      官方 import 定义: https://developers.google.com/protocol-buffers/docs/proto3#importing_definitions import 使用案例: https://mileslin.github.io/2020/04/Golang/Import-%E5%85%B6%E4%BB%96-proto/  import 相同 package 的文件 import 不同 package 的吻额间 使用 import public 降低 proto 目录迁移成本    ","description":"使用 import 引入其他包     在使用 grpc 的时候，不可避免的会用到 其他 proto 文件。 这时就需要在 proto 文件中使用 import 语法。\n如果不了解 import 的路径规则， 那么可能出现以下错误。\nImport \u0026quot;model.proto\u0026quot; was not found or had errors. 使用 import     创建 model.proto 定义一个 ProdModel 的消息体(message)\n// model.proto syntax=\u0026#34;proto3\u0026#34;;option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;message ProdModel { int32 prod_id=1; string prod_name=2; float prod_price=3;}在 prod.proto 文件中使用 import 引入 model.proto\n// prod.proto syntax=\u0026#34;proto3\u0026#34;;option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;package grpc_go_demo.prod;// 引入文件 import \u0026#34;pkg/services/model.proto\u0026#34;;service ProdService { rpc GetProdStock(ProdRequest) returns (ProdResponse); rpc GetProdModel(ProdRequest) returns (ProdModel); // 添加新接口 }虽然 prod."},{"id":6,"href":"/books/grpc-go/grpc-go/05-repeated-return-slice-type/","title":"5. repeated 返回数组","parent":"gRPC-Go","content":"使用 repeated 返回数组或切片     在 proto 如果要表示某个字段是数组， 需要在定义某一个字段的时候使用 repeated 作为修饰符。\n如下\nmessage ProdResponse{ int32 prod_stock=1; // 商品库存 }message ProdResponseList { repeated ProdResponse prods=1; // ProdResponse 数组 }编译结果如下\ntype ProdResponseList struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Prods []*ProdResponse `protobuf:\u0026#34;bytes,1,rep,name=prods,proto3\u0026#34; json:\u0026#34;prods,omitempty\u0026#34;` } ","description":"使用 repeated 返回数组或切片     在 proto 如果要表示某个字段是数组， 需要在定义某一个字段的时候使用 repeated 作为修饰符。\n如下\nmessage ProdResponse{ int32 prod_stock=1; // 商品库存 }message ProdResponseList { repeated ProdResponse prods=1; // ProdResponse 数组 }编译结果如下\ntype ProdResponseList struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Prods []*ProdResponse `protobuf:\u0026#34;bytes,1,rep,name=prods,proto3\u0026#34; json:\u0026#34;prods,omitempty\u0026#34;` } "},{"id":7,"href":"/books/grpc-go/grpc-go/06-enum-type/","title":"6. 枚举类型","parent":"gRPC-Go","content":"枚举类型     在 proto 中定义一个 枚举 类型还是很简单的\nenum ProdArea { A=0; // 第一个必须是0 ， 表示默认值  B=1; C=2;}在 proto3 语法中， 定义枚举类型的第一个枚举值必须为 0 ， 否则编译将报错（如下）。 同时该枚举值也是 默认值 。\nprotos/services/prod_enum.proto:6:7: The first enum value must be zero in proto3. 在编译成 go 以后， 对应创建了一个新的类型 ProdArea， 以及初始化一些 常量。\ntype ProdArea int32 const ( ProdArea_A ProdArea = 0 // 第一个必须是0 ， 表示默认值 \tProdArea_B ProdArea = 1 ProdArea_C ProdArea = 2 ) 同时， ProdArea 提供了 String() 方法得到 枚举值 的字面量。\nfunc (x ProdArea) String() string { return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x)) } ","description":"枚举类型     在 proto 中定义一个 枚举 类型还是很简单的\nenum ProdArea { A=0; // 第一个必须是0 ， 表示默认值  B=1; C=2;}在 proto3 语法中， 定义枚举类型的第一个枚举值必须为 0 ， 否则编译将报错（如下）。 同时该枚举值也是 默认值 。\nprotos/services/prod_enum.proto:6:7: The first enum value must be zero in proto3. 在编译成 go 以后， 对应创建了一个新的类型 ProdArea， 以及初始化一些 常量。\ntype ProdArea int32 const ( ProdArea_A ProdArea = 0 // 第一个必须是0 ， 表示默认值 \tProdArea_B ProdArea = 1 ProdArea_C ProdArea = 2 ) 同时， ProdArea 提供了 String() 方法得到 枚举值 的字面量。"},{"id":8,"href":"/books/grpc-go/grpc-go/07-protoc-compile-in-go/","title":"7. 编译成 Golang 依赖","parent":"gRPC-Go","content":"protoc 编译 go module 特有参数      https://developers.google.com/protocol-buffers/docs/reference/go-generated#invocation\n 实现 proto 与 go 代码分离     如果将编译后生成的代码文件和 proto 文件放在一起的话， 目录内文件看起来乱糟糟的， 当然也不是什么大事。 但如果要为不同语言编译对应的库文件， 就不方便进行管理了。\n如下， proto 文件单独一个分支目录， 编译的 go 文件单独一个分支目录。 就清爽多了。\n. ├── pkg │ └── services │ ├── prod.pb.go │ ├── prod_enum.pb.go │ └── prod_server_grpc.pb.go └── protos └── services ├── prod.proto ├── prod_enum.proto └── prod_server.proto 在 proto 文件中， 其中有一个 go 特有的参数 option go_package， 其作用就是指定编译后生成文件的存放路径， 也就是 go 中 import 此包的地址。\nsyntax=\u0026#34;proto3\u0026#34;;option go_package = \u0026#34;github.com/tangx/grpc-go-demo/pkg/services\u0026#34;;在 protoc 编译参数中 --go_opt 和 --go-grpc_opt 都支持一个 module flag。 该 flag 指定的就是 go.mod 文件中的 module 地址\n// go.mod module github.com/tangx/grpc-go-demo go 1.17 在 protoc 编译参数使用该 flag 可以直接将编译的文件保存到 1. 从执行 protoc 的工作目录 开始计算的 2. 基于 module 的相对地址。\n举个例子\n go_package github.com/tangx/grpc-go-demo/pkg/services  除去 module github.com/tangx/grpc-go-demo 后的 相对地址是 pkg/services， 即 xxx.pb.go 文件的保存路径。   当前目录 执行 protoc 命令，  则在 当前目录 创建 pkg/services 目录 将编译生成的 xxx.pb.go 文件放进去。    vscode extension 配置     下面为扩展 vscode-proto3 在工程目录的配置， 将 github.com/tangx/grpc-go-demo 替换成实际的值即可。\n// .vscode/settings.json { \u0026quot;protoc\u0026quot;: { \u0026quot;path\u0026quot;:\u0026quot;/usr/local/protoc/bin/protoc\u0026quot;, \u0026quot;compile_on_save\u0026quot;: true, \u0026quot;options\u0026quot;: [ \u0026quot;--proto_path=${workspaceRoot}/\u0026quot;, \u0026quot;--go_out=.\u0026quot;, \u0026quot;--go_opt=module=github.com/tangx/grpc-go-demo\u0026quot;, \u0026quot;--go-grpc_out=.\u0026quot;, \u0026quot;--go-grpc_opt=module=github.com/tangx/grpc-go-demo\u0026quot;, ] } }  注意: 经过反复测试，--proto_path=${workspaceRoot}/ 只写一个， 且值为 工程目录 编译结果最靠谱。 代价就是需要在 proto 文件中 import 的时候写上目标文件的全路径。\n ","description":"protoc 编译 go module 特有参数      https://developers.google.com/protocol-buffers/docs/reference/go-generated#invocation\n 实现 proto 与 go 代码分离     如果将编译后生成的代码文件和 proto 文件放在一起的话， 目录内文件看起来乱糟糟的， 当然也不是什么大事。 但如果要为不同语言编译对应的库文件， 就不方便进行管理了。\n如下， proto 文件单独一个分支目录， 编译的 go 文件单独一个分支目录。 就清爽多了。\n. ├── pkg │ └── services │ ├── prod.pb.go │ ├── prod_enum.pb.go │ └── prod_server_grpc.pb.go └── protos └── services ├── prod.proto ├── prod_enum.proto └── prod_server.proto 在 proto 文件中， 其中有一个 go 特有的参数 option go_package， 其作用就是指定编译后生成文件的存放路径， 也就是 go 中 import 此包的地址。"},{"id":9,"href":"/books/grpc-go/grpc-go/","title":"gRPC-Go","parent":"","content":"","description":""},{"id":10,"href":"/books/grpc-go/tags/","title":"Tags","parent":"","content":"","description":""}]
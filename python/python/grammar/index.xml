<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2. 基础语法 on Python 3</title><link>https://typonotes.com/books/python/python/grammar/</link><description>Recent content in 2. 基础语法 on Python 3</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/python/python/grammar/index.xml" rel="self" type="application/rss+xml"/><item><title>1. 字符串操作</title><link>https://typonotes.com/books/python/python/grammar/string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/string/</guid><description>https://docs.python.org/zh-cn/3.7/library/string.html
1. 字符串拼接 使用 + 拼接 使用 f&amp;quot;format {var}&amp;quot; 模版字符串 name = &amp;#34;Alice&amp;#34; age = 20 print(&amp;#34;Hello, &amp;#34; + name + &amp;#34;!&amp;#34;) print(&amp;#34;You are &amp;#34; + str(age) + &amp;#34; years old.&amp;#34;) print(f&amp;#34;Hello, {name}, you are {age}!&amp;#34;) 使用 乘法运算符* 可以重复字符串数次 print(&amp;#34;Hello, &amp;#34; * 3) # Hello, Hello, Hello, ⚠️ 注意 : 以下字符串拼接的方法合适， 但不建议。 pylint 会给出提示
print(&amp;#34;Hello, %s, you are %d!&amp;#34; % (name, age)) print(&amp;#34;Hello, {name}, you are {age}!</description></item><item><title>3. 流程控制</title><link>https://typonotes.com/books/python/python/grammar/controlflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/controlflow/</guid><description>https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html
1. if&amp;hellip;else if ... elif ... else
复合条件: and, or
if a &amp;gt; 0 and a &amp;lt;= 40: print(&amp;#34;40 &amp;gt; a &amp;gt; 0&amp;#34;) elif a &amp;gt; 40: print(&amp;#34;a &amp;gt; 40&amp;#34;) else: print(&amp;#34;a &amp;lt; 0&amp;#34;) 2. for in for in list words = [&amp;#39;cat&amp;#39;, &amp;#39;window&amp;#39;, &amp;#39;defenestrate&amp;#39;] for w in words: print(w, len(w)) for in dict
使用 copy() 生成一个副本， 避免 源 被修改后造成数据污染。</description></item><item><title>4. 函数定义</title><link>https://typonotes.com/books/python/python/grammar/function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/function/</guid><description>https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions
1. 定义函数 def 关键字 -&amp;gt; 指定返回值 -&amp;gt; xx : 一个返回值 -&amp;gt; tuple[xx, yy] : 多个返回值 -&amp;gt; None 或 省略 : 无返回值 def hello(): print(&amp;#34;Hello Python&amp;#34;) def hi() -&amp;gt; None: print(&amp;#34;Hello Python&amp;#34;) def add(a: int, b: int) -&amp;gt; int: return a + b def calc(a: int, b: int) -&amp;gt; tuple[int, int]: return a + b, a - b 2. 参数 name 比选参数 age 默认参数， 可选参数。 def hello(name: str, age: int = 20): print(f&amp;#34;Hello {name}, you are {age}years old.</description></item><item><title>exception 异常</title><link>https://typonotes.com/books/python/python/grammar/exception/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/exception/</guid><description>https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exceptions
1. 创建和抛出异常 创建简单异常 # 创建异常 e = Exception(&amp;#34;a new Error&amp;#34;) # 抛出异常 raise e 自定义异常 https://docs.python.org/zh-cn/3.13/tutorial/errors.html#user-defined-exceptions
class ZeroDivisionError(ArithmeticError): ... class ArithmeticError(Exception): ... 2. 异常链、 异常组、 except* https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exception-chaining
&amp;hellip;</description></item><item><title>try 异常处理</title><link>https://typonotes.com/books/python/python/grammar/try-finally/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/try-finally/</guid><description>https://docs.python.org/zh-cn/3.13/tutorial/errors.html#handling-exceptions
1. try 处理异常 try...: 语句用于管理 期望逻辑 except: 顺序很重要: 多个 except 从上往下检查， 匹配成功后终止后续匹配。 异常覆盖返回应该 从小到大。 如果将 Exception 将放在前面， 则将屏蔽后续所有异常。 同一行写多个异常的时候， 应该使用 圆括号() 包裹起来。 可以使用 as {e} 将异常保存到变量 e 中， 方便代码处理。 else: 当 try 语句块正常结束，且没有 break / return 改变流程时执行 finally: 永远都会执行， 常用于释放资源。 如文件句柄、网络连接等 def divide(n1: int, n2: int) -&amp;gt; float | Exception: try: n = n1 / n2 # except Exception as e: # 捕获所有异常， 后续都不会执行， 应该放在最后。 # print(f&amp;#34;捕获到异常: {e}&amp;#34;) # return e except (ZeroDivisionError, OSError): return Exception(&amp;#34;Division by zero&amp;#34;) except TypeError as e: return Exception(f&amp;#34;Invalid type, {e}&amp;#34;) else: # 当 try 语句块正常结束， 且没有 break / return 改变流程时执行 print(&amp;#34;This will execute if no exception is raised&amp;#34;) return n finally: # 永远都会执行， 用于释放资源 print(&amp;#34;This will always execute&amp;#34;) 2.</description></item><item><title>with</title><link>https://typonotes.com/books/python/python/grammar/with/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/python/python/grammar/with/</guid><description>with 是 python 中的一个关键字。 一种更简单的方式实现 try...catch。
例如， 打开文件后获得文件句柄f， 无论执行是否正常都需要关闭句柄。
try: f = open(&amp;#34;file.txt&amp;#34;, &amp;#34;r&amp;#34;) f.write(&amp;#34;Hello, World!&amp;#34;) finally: f.close() 但是使用 with 关键字， 就可以简单的写成如下
with open(&amp;#34;file.txt&amp;#34;, &amp;#34;w&amp;#34;) as f: f.write(&amp;#34;Hello, World!&amp;#34;) with...as 的类实现: ContextManager with 执行的对象需要实现两个 内置方法
__enter__() __exit__() 只要有这两个方法， 就算实现了 ContextManager， 就可以使用 with 捕获。
class MyContextManager: def __enter__(self): print(&amp;#34;Entered&amp;#34;) return self def __exit__(self, exc_type, exc_val, exc_tb): print(&amp;#34;Exited&amp;#34;) def do_something(self): print(&amp;#34;Doing something&amp;#34;) 这个有点像 golang 中的接口
type WithContextManager interface{ Enter() Exit() } with.</description></item></channel></rss>
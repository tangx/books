[{"id":0,"href":"/books/python/","title":"","parent":"","content":"Python 3     ","description":"Python 3     "},{"id":1,"href":"/books/python/python/library/httpx/","title":"Httpx","parent":"2. 常用库","content":"","description":""},{"id":2,"href":"/books/python/SUMMARY/","title":"Summary","parent":"","content":"Python 3 学习笔记     ","description":"Python 3 学习笔记     "},{"id":3,"href":"/books/python/python/library/ospath/","title":"1. os.path 路径操作","parent":"2. 常用库","content":" __file__ 当前文件 os.path.abspath() : 获取绝对路径 os.path.dirname() : 文件夹路径 os.path.basename() : 文件名称 os.path.join() : 拼凑路径， 可以规避系统路径分割问题。  current_file_path = os.path.abspath(__file__) basename = os.path.basename(__file__) dirname = os.path.dirname(__file__) target = os.path.join(dirname, basename) ","description":" __file__ 当前文件 os.path.abspath() : 获取绝对路径 os.path.dirname() : 文件夹路径 os.path.basename() : 文件名称 os.path.join() : 拼凑路径， 可以规避系统路径分割问题。  current_file_path = os.path.abspath(__file__) basename = os.path.basename(__file__) dirname = os.path.dirname(__file__) target = os.path.join(dirname, basename) "},{"id":4,"href":"/books/python/advanced/pytest/","title":"1. pytest","parent":"9. 工程化","content":"pytest      https://docs.pytest.org/en/stable/\n 安装 Python 和 Python-Debugger 之后， 可以在 VSCode 使用 pytest 进行单元测试\n1. 启用 pytest     在项目 .vscode/settings.json 中添加配置启用 pytest 测试。\n{ \u0026#34;python.testing.pytestArgs\u0026#34;: [ \u0026#34;.\u0026#34; ], \u0026#34;python.testing.unittestEnabled\u0026#34;: false, // 关闭 unittest \u0026#34;python.testing.pytestEnabled\u0026#34;: true, // 启用 pytest } 2. 创建 test 文件     pytest 自动检查并 并发 运行所有测试用例。\n测试文件的编程规则与基本文件一致。 但需要遵循以下命名规则\n 测试文件命名规则为 test_{xxx}.py 测试函数命名规则为 test_{func}  测试函数中使用 assert 推断结果。    更多测试规则参考 pytest 官方文档: https://docs.pytest.org/en/stable/example/index.html\n# teset_sum_file.py from .sum_file import add_func def test_sum_func(): assert add_func(10, 5) == 15 assert add_func(10, -5) == 5 def test_my_func(): assert add_func(10, 5) \u0026lt;= 20 之后便可在插件栏找到 烧瓶 执行测试\n 3. conftest.py      https://docs.pytest.org/en/stable/how-to/assert.html#assertion-rewriting-caches-files-on-disk\n 在根目录下创建 conftest.py 禁止生成测试缓存\nimport sys sys.dont_write_bytecode = True ","description":"pytest      https://docs.pytest.org/en/stable/\n 安装 Python 和 Python-Debugger 之后， 可以在 VSCode 使用 pytest 进行单元测试\n1. 启用 pytest     在项目 .vscode/settings.json 中添加配置启用 pytest 测试。\n{ \u0026#34;python.testing.pytestArgs\u0026#34;: [ \u0026#34;.\u0026#34; ], \u0026#34;python.testing.unittestEnabled\u0026#34;: false, // 关闭 unittest \u0026#34;python.testing.pytestEnabled\u0026#34;: true, // 启用 pytest } 2. 创建 test 文件     pytest 自动检查并 并发 运行所有测试用例。\n测试文件的编程规则与基本文件一致。 但需要遵循以下命名规则\n 测试文件命名规则为 test_{xxx}.py 测试函数命名规则为 test_{func}  测试函数中使用 assert 推断结果。    更多测试规则参考 pytest 官方文档: https://docs."},{"id":5,"href":"/books/python/python/types/stdtypes/","title":"1. 内置类型","parent":"2. 类型检查","content":"1. 常见内置类型      https://docs.python.org/3/library/stdtypes.html\n name: str = \u0026#34;Tom\u0026#34; # 字符串 age: int = 20 height: float = 1.75 male: bool = True scores: list = [90, 80, 85] # 列表 info: dict = {\u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;: 20} # 字典 z: complex = 1 + 2j # 复数 ","description":"1. 常见内置类型      https://docs.python.org/3/library/stdtypes.html\n name: str = \u0026#34;Tom\u0026#34; # 字符串 age: int = 20 height: float = 1.75 male: bool = True scores: list = [90, 80, 85] # 列表 info: dict = {\u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;: 20} # 字典 z: complex = 1 + 2j # 复数 "},{"id":6,"href":"/books/python/python/voyage/","title":"1. 准备知识","parent":"2. Python 基础","content":"","description":""},{"id":7,"href":"/books/python/python/grammar/string/","title":"1. 字符串操作","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.7/library/string.html\n 1. 字符串拼接      使用 + 拼接 使用 f\u0026quot;format {var}\u0026quot; 模版字符串  name = \u0026#34;Alice\u0026#34; age = 20 print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) print(\u0026#34;You are \u0026#34; + str(age) + \u0026#34; years old.\u0026#34;) print(f\u0026#34;Hello, {name}, you are {age}!\u0026#34;) 使用 乘法运算符* 可以重复字符串数次  print(\u0026#34;Hello, \u0026#34; * 3) # Hello, Hello, Hello,  ⚠️ 注意 : 以下字符串拼接的方法合适， 但不建议。 pylint 会给出提示\n print(\u0026#34;Hello, %s, you are %d!\u0026#34; % (name, age)) print(\u0026#34;Hello, {name}, you are {age}!\u0026#34;.format(name=name, age=age)) print(\u0026#34;Hello, {0}, you are {1}!\u0026#34;.format(name, age)) print(\u0026#34;Hello, {}, you are {}!\u0026#34;.format(name, age)) # Formatting a regular string which could be an f-string # PylintC0209:consider-using-f-string 2. 字符串格式化      https://docs.python.org/zh-cn/3.7/library/string.html#format-examples\n 使用 {:xxx} 操作符 格式化字符串\n 该语法在大多数情况下与旧式的 % 格式化类似，只是增加了 {} 和 : 来取代 %。 例如，，'%03.2f' 可以被改写为 '{:03.2f}'。\n \u0026#39;{:\u0026lt;30}\u0026#39;.format(\u0026#39;left aligned\u0026#39;) # \u0026#39;left aligned \u0026#39; \u0026#39;{:\u0026gt;30}\u0026#39;.format(\u0026#39;right aligned\u0026#39;) # \u0026#39; right aligned\u0026#39; 3. 大小写     与 javascript 类似， 字符串大小写操作都是 自身方法 。\n title() : 每个单词首字母 都大写。 capitalize() : 一句话只有 第一个 字母大写。  # upper and lower print(name.upper()) # ALICE print(name.lower()) # alice print(name.capitalize()) # Alice print(name.title()) # Alice print(\u0026#34;hello-world\u0026#34;.title()) # Hello World print(\u0026#34;hello world\u0026#34;.capitalize()) # Hello world 4. 字符串的分割与拼接      split() 用于 分割 字符串， 默认为 空白字符。 可以指定 分割符 join() 用于拼接字符串。  s = \u0026#34;hello, world\u0026#34; print(s.split()) # [\u0026#39;hello,\u0026#39;, \u0026#39;world\u0026#39;] print(s.split(\u0026#34;,\u0026#34;)) # [\u0026#39;hello\u0026#39;, \u0026#39; world\u0026#39;] print(\u0026#34; \u0026#34;.join([\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;])) # Hello World ","description":"https://docs.python.org/zh-cn/3.7/library/string.html\n 1. 字符串拼接      使用 + 拼接 使用 f\u0026quot;format {var}\u0026quot; 模版字符串  name = \u0026#34;Alice\u0026#34; age = 20 print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) print(\u0026#34;You are \u0026#34; + str(age) + \u0026#34; years old.\u0026#34;) print(f\u0026#34;Hello, {name}, you are {age}!\u0026#34;) 使用 乘法运算符* 可以重复字符串数次  print(\u0026#34;Hello, \u0026#34; * 3) # Hello, Hello, Hello,  ⚠️ 注意 : 以下字符串拼接的方法合适， 但不建议。 pylint 会给出提示\n print(\u0026#34;Hello, %s, you are %d!\u0026#34; % (name, age)) print(\u0026#34;Hello, {name}, you are {age}!"},{"id":8,"href":"/books/python/python/voyage/package-module/","title":"1. 模块和包","parent":"1. 准备知识","content":"模块和包      https://docs.python.org/zh-cn/3.13/tutorial/modules.html\n  在 python 中， 一个文件就是一个 模块 module 一个带有 __init__.py 的文件夹就是一个 包 package。  3. 模块（及其内容） 是最小的 import 单位。 即不能 from pkg1 import pkg2， 再使用 pkg2.module.func(1,2)\n1. 相对引用 - 同目录     同目录的时候， 建议使用 相对引用。\n$ tree . . ├── __init__.py ├── main.py # 入口文件 └── minus_file.py 举个例子\n# main.py # （相对路径） from . import minus_file # 从包中导入模块 from .minus_file import minus_func # 从模块中导入函数 if __name__ == \u0026#34;__main__\u0026#34;: print(minus_func(10, 5)) print(minus_file.minus_func(10, 5)) 2. 绝对引用 - 跨目录     跨目录的时候， 建议使用 绝对路径。\n$ tree src src ├── __init__.py └── mymath ├── __init__.py ├── calc │ ├── __init__.py │ ├── main.py ## 入口 └── increase_pkg ├── __init__.py └── sum_file.py 例如\n# 绝对路径 from src.mymath.increase_pkg import sum_file # 从包中导入模块 from src.mymath.increase_pkg.sum_file import add_func # 从模块中导入函数 if __name__ == \u0026#34;__main__\u0026#34;: print(add_func(10, 5)) print(sum_file.add_func(10, 5)) 需要注意：\n 绝对路径引用总是从 顶层 开始的。 顶层 根据 PYTHONPATH 定义的。 （使用方式与 shell PATH 相同） 如果 PYTHONPATH 包含了包的多层， 则 import 不一定从 真·顶层 开始。  例如\n# main2.py from src.mymath.increase_pkg import sum_file # 从 src 开始 from mymath.increase_pkg.sum_file import add_func # 从 mymath 开始 if __name__ == \u0026#34;__main__\u0026#34;: print(add_func(10, 5)) print(sum_file.add_func(10, 5))  当 PYTHONPATH 没有添加 src 的时候， 执行报错  export PYTHONPATH=/path/2/workspace $ python3 ./main2.py Traceback (most recent call last): File \u0026#34;/path/2/workspace/src/mymath/calc/./main2.py\u0026#34;, line 2, in \u0026lt;module\u0026gt; from mymath.increase_pkg.sum_file import add_func # 从模块中导入函数 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ModuleNotFoundError: No module named \u0026#39;mymath\u0026#39; 当 PYTHONPATH 包含 src 的时候， 执行成功  $ export PYTHONPATH=/path/2/workspace:/path/2/workspace/src $ python3 ./main2.py 15 15 参考资料      【python】关于import你需要知道的一切！一个视频足够了】  ","description":"模块和包      https://docs.python.org/zh-cn/3.13/tutorial/modules.html\n  在 python 中， 一个文件就是一个 模块 module 一个带有 __init__.py 的文件夹就是一个 包 package。  3. 模块（及其内容） 是最小的 import 单位。 即不能 from pkg1 import pkg2， 再使用 pkg2.module.func(1,2)\n1. 相对引用 - 同目录     同目录的时候， 建议使用 相对引用。\n$ tree . . ├── __init__.py ├── main.py # 入口文件 └── minus_file.py 举个例子\n# main.py # （相对路径） from . import minus_file # 从包中导入模块 from .minus_file import minus_func # 从模块中导入函数 if __name__ == \u0026#34;__main__\u0026#34;: print(minus_func(10, 5)) print(minus_file."},{"id":9,"href":"/books/python/setup/","title":"1. 环境配置","parent":"","content":"","description":""},{"id":10,"href":"/books/python/setup/install/","title":"1. 配置开发环境","parent":"1. 环境配置","content":"安装 Python     官网 https://www.python.org/downloads/\nMacOS 安装 python     安装最新版本\nbrew install python 安装指定版本\nbrew install python@3.13 使用 brew 安装的软件， 都会有软连接到 /opt/homebrew/bin 。 设置 PATH\nexport PATH=/opt/homebrew/bin:$PATH 查看 python 安装情况      注意 每一个 python 版本都有自己 独立 的依赖管理。 代码虽然通用 ， 但是 管理彼此独立。 例如在 python3.10 装了 pyyaml, 在 python3.13 还需要装一次。\n 查看所有 brew 安装的 python\n$ ls -al /opt/homebrew/bin | grep python 使用 which 查看当前的 默认 python3\n$ which python3 /opt/homebrew/bin/python3 查看 python 版本     $ python3 --version Python 3.13.2 由于 python 几乎是 Unix-Like 系统必备的软件了， 所以安装指定版本之后， 默认版本就可能不符合预期。 因此在开发的时候指定版本就很重要了。\nrequirements 管理     使用 pip freeze 会把当前环境中的所有 安装过 依赖包都放到 requirements.txt 中， 不管是否真正使用。\n可以使用 pigar 作为替代， 生成 真正 的最小化包。\npip3 install pigar 使用 pigar\npigar generate 国内镜像加速     使用国内 阿里云 镜像 ~/.pip/pip.conf\n[global] trusted-host=mirrors.aliyun.com index-url=http://mirrors.aliyun.com/pypi/simple/ ","description":"安装 Python     官网 https://www.python.org/downloads/\nMacOS 安装 python     安装最新版本\nbrew install python 安装指定版本\nbrew install python@3.13 使用 brew 安装的软件， 都会有软连接到 /opt/homebrew/bin 。 设置 PATH\nexport PATH=/opt/homebrew/bin:$PATH 查看 python 安装情况      注意 每一个 python 版本都有自己 独立 的依赖管理。 代码虽然通用 ， 但是 管理彼此独立。 例如在 python3.10 装了 pyyaml, 在 python3.13 还需要装一次。\n 查看所有 brew 安装的 python\n$ ls -al /opt/homebrew/bin | grep python 使用 which 查看当前的 默认 python3"},{"id":11,"href":"/books/python/python/voyage/execute/","title":"2. Python 启动方式","parent":"1. 准备知识","content":"1. 交互终端     在命令行中执行 python 进入交互终端\n$ python3 Python 3.12.9 (main, Feb 4 2025, 14:38:38) [Clang 16.0.0 (clang-1600.0.26.6)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; 2. 执行文件     单文件应用 可以使用这种方式\n$ python3 main.py 通常会判断 __name__ 的值进行启动。\ndef hello(name: string): print(f\u0026#34;Hello, {name}!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: hello(\u0026#34;Python\u0026#34;) 3. 执行模块     当自己创建复杂的 包 或 模块 的时候。\n这种方法最通用。\n$ python -m src.mymath.calc.main Hello, Python! ","description":"1. 交互终端     在命令行中执行 python 进入交互终端\n$ python3 Python 3.12.9 (main, Feb 4 2025, 14:38:38) [Clang 16.0.0 (clang-1600.0.26.6)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; 2. 执行文件     单文件应用 可以使用这种方式\n$ python3 main.py 通常会判断 __name__ 的值进行启动。\ndef hello(name: string): print(f\u0026#34;Hello, {name}!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: hello(\u0026#34;Python\u0026#34;) 3. 执行模块     当自己创建复杂的 包 或 模块 的时候。\n这种方法最通用。\n$ python -m src."},{"id":12,"href":"/books/python/python/","title":"2. Python 基础","parent":"","content":"","description":""},{"id":13,"href":"/books/python/setup/vscode/","title":"2. VSCode","parent":"1. 环境配置","content":"1. 插件 (微软插件全家桶)      Python Pylance : Python LSP Python Debugger : debug 插件 Mypy Type Checker : 类型检查 Pylint : 代码分析 Black Formatter : 格式化插件 isort : import 排序  pip3 install mypy==1.15.0 pip3 install pylint==3.3.4 pip3 install black==24.8.0 pip3 install isort==5.13.2 vscode settings.json\n{ // python \u0026#34;[python]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34; }, }, // isort \u0026#34;isort.args\u0026#34;: [ \u0026#34;--profile\u0026#34;, \u0026#34;black\u0026#34; ], // mypy \u0026#34;mypy-type-checker.importStrategy\u0026#34;: \u0026#34;useBundled\u0026#34;, \u0026#34;mypy-type-checker.args\u0026#34;: [ \u0026#34;--follow-imports=skip\u0026#34;, \u0026#34;--ignore-missing-imports\u0026#34;, \u0026#34;--show-column-numbers\u0026#34;, \u0026#34;--allow-untyped-defs\u0026#34;, \u0026#34;--allow-subclassing-any\u0026#34;, \u0026#34;--allow-untyped-calls\u0026#34;, \u0026#34;--no-warn-no-return\u0026#34; ], \u0026#34;python.analysis.inlayHints.functionReturnTypes\u0026#34;: true, \u0026#34;python.analysis.typeCheckingMode\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;python.analysis.inlayHints.callArgumentNames\u0026#34;: \u0026#34;partial\u0026#34;, \u0026#34;pythonIndent.keepHangingBracketOnLine\u0026#34;: true, \u0026#34;pythonIndent.trimLinesWithOnlyWhitespace\u0026#34;: true, \u0026#34;pythonIndent.useTabOnHangingIndent\u0026#34;: true, \u0026#34;python.analysis.inlayHints.variableTypes\u0026#34;: true, } 可选插件      代码高亮插件 Semantic highlighting : 通用插件， 可以指定 自定义类型 的颜色。  { // 定义类型提示的颜色 \u0026#34;editor.semanticTokenColorCustomizations\u0026#34;: { // 插件: https://marketplace.visualstudio.com/items?itemName=malcolmmielle.semantic-highlighting // 配置: https://stackoverflow.com/questions/71718939/syntax-highlighting-in-vscode-for-type-hints \u0026#34;rules\u0026#34;: { // 自定义类型 \u0026#34;*.typeHint\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#C5A930\u0026#34;, \u0026#34;fontStyle\u0026#34;: [ \u0026#34;italic\u0026#34;, \u0026#34;bold\u0026#34;, \u0026#34;underline\u0026#34; ] }, // 内建类型 \u0026#34;class.typeHint.builtin\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#6156AB\u0026#34;, \u0026#34;fontStyle\u0026#34;: \u0026#34;italic\u0026#34; } } }, } 2. 替代插件 uv, ruff     uv 和 ruff 使用 rust 编写， 是 包管理 和 lsp, lint, etc. 的替代方案。\n$ brew install uv $ brew install ruff 2.1. uv      https://docs.astral.sh/uv/\n uv init {project_name} uv add {pkg_name} uv remove {pkg_name} uv sync # 重新安装所有包 2.2. ruff      https://docs.astral.sh/ruff/\n  Ruff  { \u0026#34;[python]\u0026#34;: { // \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;charliermarsh.ruff\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34;, \u0026#34;source.fixAll\u0026#34;: \u0026#34;explicit\u0026#34; }, }, // python - ruff \u0026#34;ruff.trace.server\u0026#34;: \u0026#34;messages\u0026#34;, \u0026#34;ruff.nativeServer\u0026#34;: \u0026#34;on\u0026#34;, } ","description":"1. 插件 (微软插件全家桶)      Python Pylance : Python LSP Python Debugger : debug 插件 Mypy Type Checker : 类型检查 Pylint : 代码分析 Black Formatter : 格式化插件 isort : import 排序  pip3 install mypy==1.15.0 pip3 install pylint==3.3.4 pip3 install black==24.8.0 pip3 install isort==5.13.2 vscode settings.json\n{ // python \u0026#34;[python]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34; }, }, // isort \u0026#34;isort.args\u0026#34;: [ \u0026#34;--profile\u0026#34;, \u0026#34;black\u0026#34; ], // mypy \u0026#34;mypy-type-checker."},{"id":14,"href":"/books/python/python/grammar/","title":"2. 基础语法","parent":"2. Python 基础","content":"","description":""},{"id":15,"href":"/books/python/python/library/","title":"2. 常用库","parent":"2. Python 基础","content":"","description":""},{"id":16,"href":"/books/python/python/library/file/","title":"2. 文件操作","parent":"2. 常用库","content":" 读取文件 with open 使用 for line in file 读取每一行  def open_file(name: str): \u0026#34;\u0026#34;\u0026#34;Open file and print the content.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: for line in file: print(line, end=\u0026#34;\u0026#34;) file.close() 写入文件  def write_file(name: str, content: str): \u0026#34;\u0026#34;\u0026#34;Write content to file.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, \u0026#34;a\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: file.write(content) file.close() open mode      https://docs.python.org/zh-cn/3.13/tutorial/inputoutput.html#reading-and-writing-files\n  'r' ，表示文件只能读取； 默认值 'w' 表示只能写入（现有同名文件会被 覆盖）； 'a' 表示打开文件并 追加内容，任何写入的数据会自动 添加到文件末尾。 'r+' 表示打开文件进行 读写。  mode 实参是可选的，省略时的默认值为 \u0026lsquo;r\u0026rsquo;。\n","description":"读取文件 with open 使用 for line in file 读取每一行  def open_file(name: str): \u0026#34;\u0026#34;\u0026#34;Open file and print the content.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: for line in file: print(line, end=\u0026#34;\u0026#34;) file.close() 写入文件  def write_file(name: str, content: str): \u0026#34;\u0026#34;\u0026#34;Write content to file.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, \u0026#34;a\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: file.write(content) file.close() open mode      https://docs.python.org/zh-cn/3.13/tutorial/inputoutput.html#reading-and-writing-files\n  'r' ，表示文件只能读取； 默认值 'w' 表示只能写入（现有同名文件会被 覆盖）； 'a' 表示打开文件并 追加内容，任何写入的数据会自动 添加到文件末尾。 'r+' 表示打开文件进行 读写。  mode 实参是可选的，省略时的默认值为 \u0026lsquo;r\u0026rsquo;。"},{"id":17,"href":"/books/python/advanced/loguru/","title":"2. 日志库 loguru","parent":"9. 工程化","content":"loguru 是一款常用的 python 日志库。\n https://loguru.readthedocs.io/en/stable/overview.html\n  注意: loguru 没有 fatal， 而是 critical\n 安装\npip install loguru 基础使用     from loguru import logging as log ## 设置格式 logger.add(\u0026#34;file.log\u0026#34;, format=\u0026#34;{time}{level}{message}\u0026#34;, level=\u0026#34;INFO\u0026#34;) ## 设置 level logger.level(\u0026#34;ERROR\u0026#34;) # 注意， 不支持小写 logger.info(\u0026#34;Hello, World!\u0026#34;) logger.critical(\u0026#34;This is a critical message!\u0026#34;) 装饰器用法     @logger.catch def test_logger(x: int): log.info(\u0026#34;This is a test logger function!\u0026#34;) return 10 / x 绑定额外参数     #### Structured logging as needed logger.add(sys.stdout, format=\u0026#34;{extra[ip]}{extra[user]}{message}\u0026#34;) log = logger.bind(ip=\u0026#34;192.168.0.1\u0026#34;, user=\u0026#34;someone\u0026#34;) log.info(\u0026#34;Contextualize your logger easily\u0026#34;) log.bind(user=\u0026#34;someone_else\u0026#34;).info(\u0026#34;Inline binding of extra attribute\u0026#34;) log.info(\u0026#34;Use kwargs to add context during formatting: {user}\u0026#34;, user=\u0026#34;anybody\u0026#34;) ###  额外参数需要使用 {extra[xxx]} 引用 xxx 必须要存在并赋值， 否则报错。  例如这里没有给 ip 赋值默认值。\nlogger.add(sys.stdout, format=\u0026#34;{extra[ip]}{extra[user]}{message}\u0026#34;) log = logger.bind(user=\u0026#34;someone\u0026#34;) log.info(\u0026#34;Contextualize your logger easily\u0026#34;) Traceback (most recent call last): File \u0026#34;/Users/franktang/data/pypath/py-demo/.venv/lib/python3.13/site-packages/loguru/_handler.py\u0026#34;, line 184, in emit formatted = precomputed_format.format_map(formatter_record) KeyError: \u0026#39;ip\u0026#39; ","description":"loguru 是一款常用的 python 日志库。\n https://loguru.readthedocs.io/en/stable/overview.html\n  注意: loguru 没有 fatal， 而是 critical\n 安装\npip install loguru 基础使用     from loguru import logging as log ## 设置格式 logger.add(\u0026#34;file.log\u0026#34;, format=\u0026#34;{time}{level}{message}\u0026#34;, level=\u0026#34;INFO\u0026#34;) ## 设置 level logger.level(\u0026#34;ERROR\u0026#34;) # 注意， 不支持小写 logger.info(\u0026#34;Hello, World!\u0026#34;) logger.critical(\u0026#34;This is a critical message!\u0026#34;) 装饰器用法     @logger.catch def test_logger(x: int): log.info(\u0026#34;This is a test logger function!\u0026#34;) return 10 / x 绑定额外参数     #### Structured logging as needed logger."},{"id":18,"href":"/books/python/python/types/typed-dict/","title":"2. 类型字典","parent":"2. 类型检查","content":"具有类型的字典， 类似于 golang 中的 struct\n1. 声明具有类型的字典      使用 class 创建带有类型的字典。 必须有 @dataclass 进行封装， 否则就是一个类 创建实例对象时， 和 类 操作方式一样。  User(name=\u0026quot;John\u0026quot;, age=30, city=\u0026quot;New York\u0026quot;)   可选字段使用 Optional 声明， 并 赋值 None。  Optional 是 Union[XXX, None] 的简写形式   可以 嵌套  from dataclasses import dataclass from typing import Dict, Optional, Union @dataclass class Address: street: str city: str zip_code: str @dataclass class User: name: str age: int city: str address: Union[Address, None] = None # You can use Optional[X] as a shorthand for Union[X, None]. addr: Optional[Address] = None user = User(name=\u0026#34;John\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) usres: Dict[str, User] = { \u0026#34;user1\u0026#34;: User(name=\u0026#34;John\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;), \u0026#34;user2\u0026#34;: User( name=\u0026#34;Tom\u0026#34;, age=35, city=\u0026#34;Chicago\u0026#34;, address=Address(\u0026#34;Main St\u0026#34;, \u0026#34;Chicago\u0026#34;, \u0026#34;12345\u0026#34;), ), \u0026#34;user3\u0026#34;: User( name=\u0026#34;Jane\u0026#34;, age=25, city=\u0026#34;Los Angeles\u0026#34;, addr=Address(\u0026#34;Main St\u0026#34;, \u0026#34;Los Angeles\u0026#34;, \u0026#34;12345\u0026#34;), ), } 2. 可选值的操作      边界守卫: 可以使用 xxx is not None 进行边界判断 忽略提示: 当直接使用了可选值时， Mypy 会提示错误， 使用 # type: ignore 可以忽略。  user1 = usres[\u0026#34;user1\u0026#34;] # 边界判断 if user1.addr is not None: print(user.addr.city) # Item \u0026#34;None\u0026#34; of \u0026#34;Address | None\u0026#34; has no attribute \u0026#34;city\u0026#34;Mypyunion-attr else: print(\u0026#34;User has no address\u0026#34;) ## 忽略提示 user2 = usres[\u0026#34;user2\u0026#34;] print(user2.address.city) # type: ignore 3. 遍历对象     获取的 user2 本质是一个 class(User) 实例， 并不是一个 字典。 如果想要像字典一样遍历他， 需要使用 __dict__.items()\nuser2: User = usres[\u0026#34;user2\u0026#34;] print(user2.address.city) # type: ignore for k2, v2 in user2.__dict__.items(): print(f\u0026#34; {k2}: {v2}\u0026#34;) 4. 文件映射      都是 copilot 生成的代码， 看不懂这些复杂的语法。\n  将内容写入文件 从文件中读取内容  # 写入文件 with open(\u0026#34;data.json\u0026#34;, \u0026#34;w\u0026#34;) as f: json.dump(usres, f, default=lambda o: o.__dict__) ## 读取文件 with open(\u0026#34;data.json\u0026#34;, \u0026#34;r\u0026#34;) as f: data = json.load(f) users2: Dict[str, User] = {k: User(**v) for k, v in data.items()} print(users2) ","description":"具有类型的字典， 类似于 golang 中的 struct\n1. 声明具有类型的字典      使用 class 创建带有类型的字典。 必须有 @dataclass 进行封装， 否则就是一个类 创建实例对象时， 和 类 操作方式一样。  User(name=\u0026quot;John\u0026quot;, age=30, city=\u0026quot;New York\u0026quot;)   可选字段使用 Optional 声明， 并 赋值 None。  Optional 是 Union[XXX, None] 的简写形式   可以 嵌套  from dataclasses import dataclass from typing import Dict, Optional, Union @dataclass class Address: street: str city: str zip_code: str @dataclass class User: name: str age: int city: str address: Union[Address, None] = None # You can use Optional[X] as a shorthand for Union[X, None]."},{"id":19,"href":"/books/python/python/types/","title":"2. 类型检查","parent":"2. Python 基础","content":"","description":""},{"id":20,"href":"/books/python/python/library/time/","title":"3. time 时间操作","parent":"2. 常用库","content":"","description":""},{"id":21,"href":"/books/python/python/grammar/controlflow/","title":"3. 流程控制","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html\n 1. if\u0026hellip;else     if ... elif ... else\n复合条件: and, or\nif a \u0026gt; 0 and a \u0026lt;= 40: print(\u0026#34;40 \u0026gt; a \u0026gt; 0\u0026#34;) elif a \u0026gt; 40: print(\u0026#34;a \u0026gt; 40\u0026#34;) else: print(\u0026#34;a \u0026lt; 0\u0026#34;) 2. for in      for in list  words = [\u0026#39;cat\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;defenestrate\u0026#39;] for w in words: print(w, len(w))  for in dict\n  使用 copy() 生成一个副本， 避免 源 被修改后造成数据污染。\n  使用 item() 生成一个可迭代对象\n  # 创建示例多项集 users = {\u0026#39;Hans\u0026#39;: \u0026#39;active\u0026#39;, \u0026#39;Éléonore\u0026#39;: \u0026#39;inactive\u0026#39;, \u0026#39;景太郎\u0026#39;: \u0026#39;active\u0026#39;} # 策略：迭代一个副本 # key =\u0026gt; user # value =\u0026gt; status for user, status in users.copy().items(): if status == \u0026#39;inactive\u0026#39;: del users[user] # 策略：创建一个新多项集 active_users = {} for user, status in users.items(): if status == \u0026#39;active\u0026#39;: active_users[user] = status 3. for/while \u0026hellip; else      在 for 或 while 循环中 break 语句可能对应一个 else 子句。 如果循环在未执行 break 的情况下结束，else 子句将会执行。 必须配合 break 使用。  4. match\u0026hellip;case      https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n  match 不支持匹配多个条件语句 case, 遇到第一个匹配直接返回。 默认值 使用 下划线 _  def http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _: return \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34;  更复杂的匹配规则: https://peps.python.org/pep-0636/\n 6. 生成可迭代对象     一些函数可以生成 可迭代对象， 并配合 for..in 使用。\n6.1. range(n)     range 可以将一个数字快速生成可迭代对象。\nfor i in range(10): print(i) 6.2. enumerate(list)     enumerate 可以将 list 生成一个字典对象， key 为数组索引。\nnames = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;] for i, name in enumerate(names): print(i, name) # 0 Alice # 1 Bob # 2 Charlie ","description":"https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html\n 1. if\u0026hellip;else     if ... elif ... else\n复合条件: and, or\nif a \u0026gt; 0 and a \u0026lt;= 40: print(\u0026#34;40 \u0026gt; a \u0026gt; 0\u0026#34;) elif a \u0026gt; 40: print(\u0026#34;a \u0026gt; 40\u0026#34;) else: print(\u0026#34;a \u0026lt; 0\u0026#34;) 2. for in      for in list  words = [\u0026#39;cat\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;defenestrate\u0026#39;] for w in words: print(w, len(w))  for in dict\n  使用 copy() 生成一个副本， 避免 源 被修改后造成数据污染。"},{"id":22,"href":"/books/python/python/library/json-yaml/","title":"4. json 和 yaml","parent":"2. 常用库","content":"1. json      json.dumps() 将 结构体 转换为 字符串 json.loads() 将 字符串 转换为 结构体  直接使用 print 打印结果看不出差别，\n[\u0026quot;zhangsan\u0026quot;, \u0026quot;lisi\u0026quot;, \u0026quot;wangwu\u0026quot;] ['zhangsan', 'lisi', 'wangwu'] 因此使用 instanceof 进行类型判断\nimport json users = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] users_dumps = json.dumps(users) # struct -\u0026gt; string print(users_dumps) print(isinstance(users_dumps, str)) # True users_loads = json.loads(users_dumps) # string -\u0026gt; struct  print(users_loads) print(isinstance(users_loads, list)) # True 2. yaml       pypi: https://pypi.org/project/PyYAML/ doc: https://pyyaml.org/wiki/PyYAMLDocumentation   yaml 并不是标准库， 需要额外安装 PyYAML\npip3 install PyYAML pip3 install types-PyYAML  虽然安装包的名字是 pyyaml， 但是使用的时候是 yaml yaml.safe_load() 解析 字符串 为 结构体。 yaml.safe_dump() 反之。  info = \u0026#34;\u0026#34;\u0026#34; name: tangx age: 20 address: contry: China city: Beijing \u0026#34;\u0026#34;\u0026#34; cfg = yaml.safe_load(info) print(cfg) cfg_dumps = yaml.safe_dump(cfg) print(cfg_dumps) 2.2. 指定 loader 和 dumper     也可以指定 Loader 和 Dumper 作为参数传递给 load() 和 dump()\nimport yaml cfg2 = yaml.load(info, Loader=yaml.SafeLoader) cfg2_dumps = yaml.dump(cfg2, Dumper=yaml.SafeDumper)  https://typonotes.com/posts/2024/11/21/python-config-pyyaml/\n 2.3. yaml 的类型问题     如果使用了 Mypy 帮助类型检查， 需要额外安装类型库\npip3 install types-PyYAML 否则会报错\n ","description":"1. json      json.dumps() 将 结构体 转换为 字符串 json.loads() 将 字符串 转换为 结构体  直接使用 print 打印结果看不出差别，\n[\u0026quot;zhangsan\u0026quot;, \u0026quot;lisi\u0026quot;, \u0026quot;wangwu\u0026quot;] ['zhangsan', 'lisi', 'wangwu'] 因此使用 instanceof 进行类型判断\nimport json users = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] users_dumps = json.dumps(users) # struct -\u0026gt; string print(users_dumps) print(isinstance(users_dumps, str)) # True users_loads = json.loads(users_dumps) # string -\u0026gt; struct  print(users_loads) print(isinstance(users_loads, list)) # True 2. yaml       pypi: https://pypi."},{"id":23,"href":"/books/python/python/grammar/function/","title":"4. 函数定义","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n 1. 定义函数      def 关键字 -\u0026gt; 指定返回值  -\u0026gt; xx : 一个返回值 -\u0026gt; tuple[xx, yy] : 多个返回值 -\u0026gt; None 或 省略 : 无返回值    def hello(): print(\u0026#34;Hello Python\u0026#34;) def hi() -\u0026gt; None: print(\u0026#34;Hello Python\u0026#34;) def add(a: int, b: int) -\u0026gt; int: return a + b def calc(a: int, b: int) -\u0026gt; tuple[int, int]: return a + b, a - b 2. 参数      name 比选参数 age 默认参数， 可选参数。  def hello(name: str, age: int = 20): print(f\u0026#34;Hello {name}, you are {age}years old.\u0026#34;) hello(\u0026#34;Alice\u0026#34;, 30) hello(\u0026#34;Bob\u0026#34;) # Hello Alice, you are 30 years old. # Hello Bob, you are 20 years old. 3. 可变参数 / 解构参数       *arg : 数组/元组参数\n  **kwarg : 字典参数\n  在 形参 的时候使用， 接受 对应类型定义参数的时候\n  def concat(*args, sep=\u0026#34;/\u0026#34;): print(sep.join(args)) concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;) # earth/mars/venus concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;, sep=\u0026#34;.\u0026#34;) # earth.mars.venus 在 实参 的时候使用， 解构 传递对应类型的参数  数组或元组\nlist(range(3, 6)) # 附带两个参数的正常调用 # [3, 4, 5] args = [3, 6] list(range(*args)) # 附带从一个列表解包的参数的调用 # [3, 4, 5] 字典\ndef hello(name, age=20): print(f\u0026#34;Hello {name}, you are {age}years old.\u0026#34;) user = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} hello(**user) # Hello Alice, you are 30 years old. ","description":"https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n 1. 定义函数      def 关键字 -\u0026gt; 指定返回值  -\u0026gt; xx : 一个返回值 -\u0026gt; tuple[xx, yy] : 多个返回值 -\u0026gt; None 或 省略 : 无返回值    def hello(): print(\u0026#34;Hello Python\u0026#34;) def hi() -\u0026gt; None: print(\u0026#34;Hello Python\u0026#34;) def add(a: int, b: int) -\u0026gt; int: return a + b def calc(a: int, b: int) -\u0026gt; tuple[int, int]: return a + b, a - b 2. 参数      name 比选参数 age 默认参数， 可选参数。  def hello(name: str, age: int = 20): print(f\u0026#34;Hello {name}, you are {age}years old."},{"id":24,"href":"/books/python/advanced/","title":"9. 工程化","parent":"","content":"","description":""},{"id":25,"href":"/books/python/python/grammar/exception/","title":"exception 异常","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exceptions\n 1. 创建和抛出异常      创建简单异常  # 创建异常 e = Exception(\u0026#34;a new Error\u0026#34;) # 抛出异常 raise e 自定义异常   https://docs.python.org/zh-cn/3.13/tutorial/errors.html#user-defined-exceptions\n class ZeroDivisionError(ArithmeticError): ... class ArithmeticError(Exception): ... 2. 异常链、 异常组、 except*      https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exception-chaining\n \u0026hellip;\n","description":"https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exceptions\n 1. 创建和抛出异常      创建简单异常  # 创建异常 e = Exception(\u0026#34;a new Error\u0026#34;) # 抛出异常 raise e 自定义异常   https://docs.python.org/zh-cn/3.13/tutorial/errors.html#user-defined-exceptions\n class ZeroDivisionError(ArithmeticError): ... class ArithmeticError(Exception): ... 2. 异常链、 异常组、 except*      https://docs.python.org/zh-cn/3.13/tutorial/errors.html#exception-chaining\n \u0026hellip;"},{"id":26,"href":"/books/python/advanced/httpx/","title":"httpx 客户端","parent":"9. 工程化","content":" https://www.python-httpx.org/\n pip3 install httpx pip3 install \u0026#34;httpx[http2]\u0026#34; # 需要使用 引号 ， 否则提示找不到 # zsh: no matches found: httpx[http2] ??? https://tangxin.github.io/moviedux/movies.json\n 使用 with 创建 http client  # myhttpx.py MOVIES = \u0026#34;https://tangxin.github.io/moviedux/movies.json\u0026#34; with httpx.Client() as client: # with 自动关闭 r = client.get(MOVIES) print(r.status_code) movies = r.json() for movie in movies: print(movie[\u0026#34;title\u0026#34;]) 使用 try\u0026hellip;finally  注意: 使用 try..except..finally 的时候， 创建 client 的语句需要写在外面。\n# myhttpx.py c2 = httpx.Client() # 创建客户端 try: r2 = c2.get(MOVIES) print(r2.status_code) movies = r2.json() for movie in movies: print(movie[\u0026#34;title\u0026#34;]) finally: c2.close() # 关闭 作用域冲突     由于在 python 中， 一个文件就是一个模块 ， 因此在进行 二次封装 的时候。 新模块不能与老模块重名， 否则会出现找不到对象方法等问题。\n ","description":"https://www.python-httpx.org/\n pip3 install httpx pip3 install \u0026#34;httpx[http2]\u0026#34; # 需要使用 引号 ， 否则提示找不到 # zsh: no matches found: httpx[http2] ??? https://tangxin.github.io/moviedux/movies.json\n 使用 with 创建 http client  # myhttpx.py MOVIES = \u0026#34;https://tangxin.github.io/moviedux/movies.json\u0026#34; with httpx.Client() as client: # with 自动关闭 r = client.get(MOVIES) print(r.status_code) movies = r.json() for movie in movies: print(movie[\u0026#34;title\u0026#34;]) 使用 try\u0026hellip;finally  注意: 使用 try..except..finally 的时候， 创建 client 的语句需要写在外面。\n# myhttpx.py c2 = httpx.Client() # 创建客户端 try: r2 = c2."},{"id":27,"href":"/books/python/tags/","title":"Tags","parent":"","content":"","description":""},{"id":28,"href":"/books/python/python/grammar/try-finally/","title":"try 异常处理","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/errors.html#handling-exceptions\n 1. try 处理异常      try...: 语句用于管理 期望逻辑 except: 顺序很重要:  多个 except 从上往下检查， 匹配成功后终止后续匹配。 异常覆盖返回应该 从小到大。 如果将 Exception 将放在前面， 则将屏蔽后续所有异常。 同一行写多个异常的时候， 应该使用 圆括号() 包裹起来。 可以使用 as {e} 将异常保存到变量 e 中， 方便代码处理。   else: 当 try 语句块正常结束，且没有 break / return 改变流程时执行 finally: 永远都会执行， 常用于释放资源。 如文件句柄、网络连接等  def divide(n1: int, n2: int) -\u0026gt; float | Exception: try: n = n1 / n2 # except Exception as e: # 捕获所有异常， 后续都不会执行， 应该放在最后。 # print(f\u0026#34;捕获到异常: {e}\u0026#34;) # return e except (ZeroDivisionError, OSError): return Exception(\u0026#34;Division by zero\u0026#34;) except TypeError as e: return Exception(f\u0026#34;Invalid type, {e}\u0026#34;) else: # 当 try 语句块正常结束， 且没有 break / return 改变流程时执行 print(\u0026#34;This will execute if no exception is raised\u0026#34;) return n finally: # 永远都会执行， 用于释放资源 print(\u0026#34;This will always execute\u0026#34;) 2. 资源打开位置     在使用 try..finally 语句的时候， 应该在 try 外面创建资源。\n# myhttpx.py import httpx c2 = httpx.Client() # 在 try 外部创建客户端 try: r2 = c2.get(MOVIES) print(r2.status_code) movies = r2.json() for movie in movies: print(movie[\u0026#34;title\u0026#34;]) finally: c2.close() # 关闭 否则在 finally 中的关闭语句， Pylance 提示 c2 is possibly unbound\n ","description":"https://docs.python.org/zh-cn/3.13/tutorial/errors.html#handling-exceptions\n 1. try 处理异常      try...: 语句用于管理 期望逻辑 except: 顺序很重要:  多个 except 从上往下检查， 匹配成功后终止后续匹配。 异常覆盖返回应该 从小到大。 如果将 Exception 将放在前面， 则将屏蔽后续所有异常。 同一行写多个异常的时候， 应该使用 圆括号() 包裹起来。 可以使用 as {e} 将异常保存到变量 e 中， 方便代码处理。   else: 当 try 语句块正常结束，且没有 break / return 改变流程时执行 finally: 永远都会执行， 常用于释放资源。 如文件句柄、网络连接等  def divide(n1: int, n2: int) -\u0026gt; float | Exception: try: n = n1 / n2 # except Exception as e: # 捕获所有异常， 后续都不会执行， 应该放在最后。 # print(f\u0026#34;捕获到异常: {e}\u0026#34;) # return e except (ZeroDivisionError, OSError): return Exception(\u0026#34;Division by zero\u0026#34;) except TypeError as e: return Exception(f\u0026#34;Invalid type, {e}\u0026#34;) else: # 当 try 语句块正常结束， 且没有 break / return 改变流程时执行 print(\u0026#34;This will execute if no exception is raised\u0026#34;) return n finally: # 永远都会执行， 用于释放资源 print(\u0026#34;This will always execute\u0026#34;) 2."},{"id":29,"href":"/books/python/python/grammar/with/","title":"with","parent":"2. 基础语法","content":"with 是 python 中的一个关键字。 一种更简单的方式实现 try...catch。\n例如， 打开文件后获得文件句柄f， 无论执行是否正常都需要关闭句柄。\ntry: f = open(\u0026#34;file.txt\u0026#34;, \u0026#34;r\u0026#34;) f.write(\u0026#34;Hello, World!\u0026#34;) finally: f.close() 但是使用 with 关键字， 就可以简单的写成如下\nwith open(\u0026#34;file.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;Hello, World!\u0026#34;) with...as 的类实现: ContextManager     with 执行的对象需要实现两个 内置方法\n __enter__() __exit__()  只要有这两个方法， 就算实现了 ContextManager， 就可以使用 with 捕获。\nclass MyContextManager: def __enter__(self): print(\u0026#34;Entered\u0026#34;) return self def __exit__(self, exc_type, exc_val, exc_tb): print(\u0026#34;Exited\u0026#34;) def do_something(self): print(\u0026#34;Doing something\u0026#34;) 这个有点像 golang 中的接口\ntype WithContextManager interface{ Enter() Exit() } with...as 的函数实现     除了类之外， 函数也可以通过 contextlib 的方式实现 Context Manager\n 注意: contextlib 是标准库\n from contextlib import contextmanager @contextmanager def my_file(): try: f = open(\u0026#34;file.txt\u0026#34;, \u0026#34;w\u0026#34;) yield f # return f ## 错误的， 会直接退出 finally: f.close() print(\u0026#34;File closed\u0026#34;) with my_file() as f: f.write(\u0026#34;Hello, World!\u0026#34;) print(\u0026#34;file update\u0026#34;)  注意: 这里 只能 使用 yield 返回句柄。\n 参考文档      Write Your Context Manager Methods in Python  ","description":"with 是 python 中的一个关键字。 一种更简单的方式实现 try...catch。\n例如， 打开文件后获得文件句柄f， 无论执行是否正常都需要关闭句柄。\ntry: f = open(\u0026#34;file.txt\u0026#34;, \u0026#34;r\u0026#34;) f.write(\u0026#34;Hello, World!\u0026#34;) finally: f.close() 但是使用 with 关键字， 就可以简单的写成如下\nwith open(\u0026#34;file.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;Hello, World!\u0026#34;) with...as 的类实现: ContextManager     with 执行的对象需要实现两个 内置方法\n __enter__() __exit__()  只要有这两个方法， 就算实现了 ContextManager， 就可以使用 with 捕获。\nclass MyContextManager: def __enter__(self): print(\u0026#34;Entered\u0026#34;) return self def __exit__(self, exc_type, exc_val, exc_tb): print(\u0026#34;Exited\u0026#34;) def do_something(self): print(\u0026#34;Doing something\u0026#34;) 这个有点像 golang 中的接口\ntype WithContextManager interface{ Enter() Exit() } with."}]
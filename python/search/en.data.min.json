[{"id":0,"href":"/books/python/","title":"","parent":"","content":"Python 3     ","description":"Python 3     "},{"id":1,"href":"/books/python/SUMMARY/","title":"Summary","parent":"","content":"Python 3 学习笔记     ","description":"Python 3 学习笔记     "},{"id":2,"href":"/books/python/python/library/ospath/","title":"1. os.path 路径操作","parent":"2. 常用库","content":" __file__ 当前文件 os.path.abspath() : 获取绝对路径 os.path.dirname() : 文件夹路径 os.path.basename() : 文件名称 os.path.join() : 拼凑路径， 可以规避系统路径分割问题。  current_file_path = os.path.abspath(__file__) basename = os.path.basename(__file__) dirname = os.path.dirname(__file__) target = os.path.join(dirname, basename) ","description":" __file__ 当前文件 os.path.abspath() : 获取绝对路径 os.path.dirname() : 文件夹路径 os.path.basename() : 文件名称 os.path.join() : 拼凑路径， 可以规避系统路径分割问题。  current_file_path = os.path.abspath(__file__) basename = os.path.basename(__file__) dirname = os.path.dirname(__file__) target = os.path.join(dirname, basename) "},{"id":3,"href":"/books/python/advanced/pytest/","title":"1. pytest","parent":"90. 更上一层楼","content":"pytest      https://docs.pytest.org/en/stable/\n 安装 Python 和 Python-Debugger 之后， 可以在 VSCode 使用 pytest 进行单元测试\n1. 启用 pytest     在项目 .vscode/settings.json 中添加配置启用 pytest 测试。\n{ \u0026#34;python.testing.pytestArgs\u0026#34;: [ \u0026#34;.\u0026#34; ], \u0026#34;python.testing.unittestEnabled\u0026#34;: false, // 关闭 unittest \u0026#34;python.testing.pytestEnabled\u0026#34;: true, // 启用 pytest } 2. 创建 test 文件     pytest 自动检查并 并发 运行所有测试用例。\n测试文件的编程规则与基本文件一致。 但需要遵循以下命名规则\n 测试文件命名规则为 test_{xxx}.py 测试函数命名规则为 test_{func}  测试函数中使用 assert 推断结果。    更多测试规则参考 pytest 官方文档: https://docs.pytest.org/en/stable/example/index.html\n# teset_sum_file.py from .sum_file import add_func def test_sum_func(): assert add_func(10, 5) == 15 assert add_func(10, -5) == 5 def test_my_func(): assert add_func(10, 5) \u0026lt;= 20 之后便可在插件栏找到 烧瓶 执行测试\n 3. conftest.py      https://docs.pytest.org/en/stable/how-to/assert.html#assertion-rewriting-caches-files-on-disk\n 在根目录下创建 conftest.py 禁止生成测试缓存\nimport sys sys.dont_write_bytecode = True ","description":"pytest      https://docs.pytest.org/en/stable/\n 安装 Python 和 Python-Debugger 之后， 可以在 VSCode 使用 pytest 进行单元测试\n1. 启用 pytest     在项目 .vscode/settings.json 中添加配置启用 pytest 测试。\n{ \u0026#34;python.testing.pytestArgs\u0026#34;: [ \u0026#34;.\u0026#34; ], \u0026#34;python.testing.unittestEnabled\u0026#34;: false, // 关闭 unittest \u0026#34;python.testing.pytestEnabled\u0026#34;: true, // 启用 pytest } 2. 创建 test 文件     pytest 自动检查并 并发 运行所有测试用例。\n测试文件的编程规则与基本文件一致。 但需要遵循以下命名规则\n 测试文件命名规则为 test_{xxx}.py 测试函数命名规则为 test_{func}  测试函数中使用 assert 推断结果。    更多测试规则参考 pytest 官方文档: https://docs."},{"id":4,"href":"/books/python/python/types/stdtypes/","title":"1. 内置类型","parent":"2. 类型检查","content":"1. 常见内置类型      https://docs.python.org/3/library/stdtypes.html\n name: str = \u0026#34;Tom\u0026#34; # 字符串 age: int = 20 height: float = 1.75 male: bool = True scores: list = [90, 80, 85] # 列表 info: dict = {\u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;: 20} # 字典 z: complex = 1 + 2j # 复数 ","description":"1. 常见内置类型      https://docs.python.org/3/library/stdtypes.html\n name: str = \u0026#34;Tom\u0026#34; # 字符串 age: int = 20 height: float = 1.75 male: bool = True scores: list = [90, 80, 85] # 列表 info: dict = {\u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;: 20} # 字典 z: complex = 1 + 2j # 复数 "},{"id":5,"href":"/books/python/python/voyage/","title":"1. 准备知识","parent":"2. Python 基础","content":"","description":""},{"id":6,"href":"/books/python/python/grammar/string/","title":"1. 字符串操作","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.7/library/string.html\n 1. 字符串拼接      使用 + 拼接 使用 f\u0026quot;format {var}\u0026quot; 模版字符串  name = \u0026#34;Alice\u0026#34; age = 20 print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) print(\u0026#34;You are \u0026#34; + str(age) + \u0026#34; years old.\u0026#34;) print(f\u0026#34;Hello, {name}, you are {age}!\u0026#34;) 使用 乘法运算符* 可以重复字符串数次  print(\u0026#34;Hello, \u0026#34; * 3) # Hello, Hello, Hello,  ⚠️ 注意 : 以下字符串拼接的方法合适， 但不建议。 pylint 会给出提示\n print(\u0026#34;Hello, %s, you are %d!\u0026#34; % (name, age)) print(\u0026#34;Hello, {name}, you are {age}!\u0026#34;.format(name=name, age=age)) print(\u0026#34;Hello, {0}, you are {1}!\u0026#34;.format(name, age)) print(\u0026#34;Hello, {}, you are {}!\u0026#34;.format(name, age)) # Formatting a regular string which could be an f-string # PylintC0209:consider-using-f-string 2. 字符串格式化      https://docs.python.org/zh-cn/3.7/library/string.html#format-examples\n 使用 {:xxx} 操作符 格式化字符串\n 该语法在大多数情况下与旧式的 % 格式化类似，只是增加了 {} 和 : 来取代 %。 例如，，'%03.2f' 可以被改写为 '{:03.2f}'。\n \u0026#39;{:\u0026lt;30}\u0026#39;.format(\u0026#39;left aligned\u0026#39;) # \u0026#39;left aligned \u0026#39; \u0026#39;{:\u0026gt;30}\u0026#39;.format(\u0026#39;right aligned\u0026#39;) # \u0026#39; right aligned\u0026#39; 3. 大小写     与 javascript 类似， 字符串大小写操作都是 自身方法 。\n title() : 每个单词首字母 都大写。 capitalize() : 一句话只有 第一个 字母大写。  # upper and lower print(name.upper()) # ALICE print(name.lower()) # alice print(name.capitalize()) # Alice print(name.title()) # Alice print(\u0026#34;hello-world\u0026#34;.title()) # Hello World print(\u0026#34;hello world\u0026#34;.capitalize()) # Hello world 4. 字符串的分割与拼接      split() 用于 分割 字符串， 默认为 空白字符。 可以指定 分割符 join() 用于拼接字符串。  s = \u0026#34;hello, world\u0026#34; print(s.split()) # [\u0026#39;hello,\u0026#39;, \u0026#39;world\u0026#39;] print(s.split(\u0026#34;,\u0026#34;)) # [\u0026#39;hello\u0026#39;, \u0026#39; world\u0026#39;] print(\u0026#34; \u0026#34;.join([\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;])) # Hello World ","description":"https://docs.python.org/zh-cn/3.7/library/string.html\n 1. 字符串拼接      使用 + 拼接 使用 f\u0026quot;format {var}\u0026quot; 模版字符串  name = \u0026#34;Alice\u0026#34; age = 20 print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) print(\u0026#34;You are \u0026#34; + str(age) + \u0026#34; years old.\u0026#34;) print(f\u0026#34;Hello, {name}, you are {age}!\u0026#34;) 使用 乘法运算符* 可以重复字符串数次  print(\u0026#34;Hello, \u0026#34; * 3) # Hello, Hello, Hello,  ⚠️ 注意 : 以下字符串拼接的方法合适， 但不建议。 pylint 会给出提示\n print(\u0026#34;Hello, %s, you are %d!\u0026#34; % (name, age)) print(\u0026#34;Hello, {name}, you are {age}!"},{"id":7,"href":"/books/python/python/voyage/package-module/","title":"1. 模块和包","parent":"1. 准备知识","content":"模块和包      https://docs.python.org/zh-cn/3.13/tutorial/modules.html\n   在 python 中， 一个文件就是一个 模块 module\n  一个带有 __init__.py 的文件夹就是一个 包 package。\n  模块（及其内容） 是最小的 import 单位。 即不能 from pkg1 import pkg2， 再使用 pkg2.module.func(1,2)\n  1. 相对引用 - 同目录     同目录的时候， 建议使用 相对引用。\n$ tree . . ├── __init__.py ├── main.py # 入口文件 └── minus_file.py 举个例子\n# main.py # （相对路径） from . import minus_file # 从包中导入模块 from .minus_file import minus_func # 从模块中导入函数 if __name__ == \u0026#34;__main__\u0026#34;: print(minus_func(10, 5)) print(minus_file.minus_func(10, 5)) 2. 绝对引用 - 跨目录     跨目录的时候， 建议使用 绝对路径。\n$ tree src src ├── __init__.py └── mymath ├── __init__.py ├── calc │ ├── __init__.py │ ├── main.py ## 入口 └── increase_pkg ├── __init__.py └── sum_file.py 例如\n# 绝对路径 from src.mymath.increase_pkg import sum_file # 从包中导入模块 from src.mymath.increase_pkg.sum_file import add_func # 从模块中导入函数 if __name__ == \u0026#34;__main__\u0026#34;: print(add_func(10, 5)) print(sum_file.add_func(10, 5)) 需要注意：\n 绝对路径引用总是从 顶层 开始的。 顶层 根据 PYTHONPATH 定义的。 （使用方式与 shell PATH 相同） 如果 PYTHONPATH 包含了包的多层， 则 import 不一定从 真·顶层 开始。  例如\n# main2.py from src.mymath.increase_pkg import sum_file # 从 src 开始 from mymath.increase_pkg.sum_file import add_func # 从 mymath 开始 if __name__ == \u0026#34;__main__\u0026#34;: print(add_func(10, 5)) print(sum_file.add_func(10, 5))  当 PYTHONPATH 没有添加 src 的时候， 执行报错  export PYTHONPATH=/path/2/workspace $ python3 ./main2.py Traceback (most recent call last): File \u0026#34;/path/2/workspace/src/mymath/calc/./main2.py\u0026#34;, line 2, in \u0026lt;module\u0026gt; from mymath.increase_pkg.sum_file import add_func # 从模块中导入函数 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ModuleNotFoundError: No module named \u0026#39;mymath\u0026#39; 当 PYTHONPATH 包含 src 的时候， 执行成功  $ export PYTHONPATH=/path/2/workspace:/path/2/workspace/src $ python3 ./main2.py 15 15 ","description":"模块和包      https://docs.python.org/zh-cn/3.13/tutorial/modules.html\n   在 python 中， 一个文件就是一个 模块 module\n  一个带有 __init__.py 的文件夹就是一个 包 package。\n  模块（及其内容） 是最小的 import 单位。 即不能 from pkg1 import pkg2， 再使用 pkg2.module.func(1,2)\n  1. 相对引用 - 同目录     同目录的时候， 建议使用 相对引用。\n$ tree . . ├── __init__.py ├── main.py # 入口文件 └── minus_file.py 举个例子\n# main.py # （相对路径） from . import minus_file # 从包中导入模块 from ."},{"id":8,"href":"/books/python/setup/","title":"1. 环境配置","parent":"","content":"","description":""},{"id":9,"href":"/books/python/setup/install/","title":"1. 配置开发环境","parent":"1. 环境配置","content":"安装 Python     官网 https://www.python.org/downloads/\nMacOS 安装 python     安装最新版本\nbrew install python 安装指定版本\nbrew install python@3.13 使用 brew 安装的软件， 都会有软连接到 /opt/homebrew/bin 。 设置 PATH\nexport PATH=/opt/homebrew/bin:$PATH 查看 python 安装情况      注意 每一个 python 版本都有自己 独立 的依赖管理。 代码虽然通用 ， 但是 管理彼此独立。 例如在 python3.10 装了 pyyaml, 在 python3.13 还需要装一次。\n 查看所有 brew 安装的 python\n$ ls -al /opt/homebrew/bin | grep python 使用 which 查看当前的 默认 python3\n$ which python3 /opt/homebrew/bin/python3 查看 python 版本     $ python3 --version Python 3.13.2 由于 python 几乎是 Unix-Like 系统必备的软件了， 所以安装指定版本之后， 默认版本就可能不符合预期。 因此在开发的时候指定版本就很重要了。\nrequirements 管理     使用 pip freeze 会把当前环境中的所有 安装过 依赖包都放到 requirements.txt 中， 不管是否真正使用。\n可以使用 pigar 作为替代， 生成 真正 的最小化包。\npip3 install pigar 使用 pigar\npigar generate 国内镜像加速     使用国内 阿里云 镜像 ~/.pip/pip.conf\n[global] trusted-host=mirrors.aliyun.com index-url=http://mirrors.aliyun.com/pypi/simple/ ","description":"安装 Python     官网 https://www.python.org/downloads/\nMacOS 安装 python     安装最新版本\nbrew install python 安装指定版本\nbrew install python@3.13 使用 brew 安装的软件， 都会有软连接到 /opt/homebrew/bin 。 设置 PATH\nexport PATH=/opt/homebrew/bin:$PATH 查看 python 安装情况      注意 每一个 python 版本都有自己 独立 的依赖管理。 代码虽然通用 ， 但是 管理彼此独立。 例如在 python3.10 装了 pyyaml, 在 python3.13 还需要装一次。\n 查看所有 brew 安装的 python\n$ ls -al /opt/homebrew/bin | grep python 使用 which 查看当前的 默认 python3"},{"id":10,"href":"/books/python/python/voyage/execute/","title":"2. Python 启动方式","parent":"1. 准备知识","content":"1. 交互终端     在命令行中执行 python 进入交互终端\n$ python3 Python 3.12.9 (main, Feb 4 2025, 14:38:38) [Clang 16.0.0 (clang-1600.0.26.6)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; 2. 执行文件     单文件应用 可以使用这种方式\n$ python3 main.py 通常会判断 __name__ 的值进行启动。\ndef hello(name: string): print(f\u0026#34;Hello, {name}!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: hello(\u0026#34;Python\u0026#34;) 3. 执行模块     当自己创建复杂的 包 或 模块 的时候。\n这种方法最通用。\n$ python -m src.mymath.calc.main Hello, Python! ","description":"1. 交互终端     在命令行中执行 python 进入交互终端\n$ python3 Python 3.12.9 (main, Feb 4 2025, 14:38:38) [Clang 16.0.0 (clang-1600.0.26.6)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; 2. 执行文件     单文件应用 可以使用这种方式\n$ python3 main.py 通常会判断 __name__ 的值进行启动。\ndef hello(name: string): print(f\u0026#34;Hello, {name}!\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: hello(\u0026#34;Python\u0026#34;) 3. 执行模块     当自己创建复杂的 包 或 模块 的时候。\n这种方法最通用。\n$ python -m src."},{"id":11,"href":"/books/python/python/","title":"2. Python 基础","parent":"","content":"","description":""},{"id":12,"href":"/books/python/setup/vscode/","title":"2. VSCode","parent":"1. 环境配置","content":"1. 插件 (微软插件全家桶)      Python Pylance : Python LSP Python Debugger : debug 插件 Mypy Type Checker : 类型检查 Pylint : 代码分析 Black Formatter : 格式化插件 isort : import 排序  pip3 install mypy==1.15.0 pip3 install pylint==3.3.4 pip3 install black==24.8.0 pip3 install isort==5.13.2 vscode settings.json\n{ // python \u0026#34;[python]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34; }, }, // isort \u0026#34;isort.args\u0026#34;: [ \u0026#34;--profile\u0026#34;, \u0026#34;black\u0026#34; ], // mypy \u0026#34;mypy-type-checker.importStrategy\u0026#34;: \u0026#34;useBundled\u0026#34;, \u0026#34;mypy-type-checker.args\u0026#34;: [ \u0026#34;--follow-imports=skip\u0026#34;, \u0026#34;--ignore-missing-imports\u0026#34;, \u0026#34;--show-column-numbers\u0026#34;, \u0026#34;--allow-untyped-defs\u0026#34;, \u0026#34;--allow-subclassing-any\u0026#34;, \u0026#34;--allow-untyped-calls\u0026#34;, \u0026#34;--no-warn-no-return\u0026#34; ], \u0026#34;python.analysis.inlayHints.functionReturnTypes\u0026#34;: true, \u0026#34;python.analysis.typeCheckingMode\u0026#34;: \u0026#34;standard\u0026#34;, \u0026#34;python.analysis.inlayHints.callArgumentNames\u0026#34;: \u0026#34;partial\u0026#34;, \u0026#34;pythonIndent.keepHangingBracketOnLine\u0026#34;: true, \u0026#34;pythonIndent.trimLinesWithOnlyWhitespace\u0026#34;: true, \u0026#34;pythonIndent.useTabOnHangingIndent\u0026#34;: true, \u0026#34;python.analysis.inlayHints.variableTypes\u0026#34;: true, } 可选插件      代码高亮插件 Semantic highlighting : 通用插件， 可以指定 自定义类型 的颜色。  { // 定义类型提示的颜色 \u0026#34;editor.semanticTokenColorCustomizations\u0026#34;: { // 插件: https://marketplace.visualstudio.com/items?itemName=malcolmmielle.semantic-highlighting // 配置: https://stackoverflow.com/questions/71718939/syntax-highlighting-in-vscode-for-type-hints \u0026#34;rules\u0026#34;: { // 自定义类型 \u0026#34;*.typeHint\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#C5A930\u0026#34;, \u0026#34;fontStyle\u0026#34;: [ \u0026#34;italic\u0026#34;, \u0026#34;bold\u0026#34;, \u0026#34;underline\u0026#34; ] }, // 内建类型 \u0026#34;class.typeHint.builtin\u0026#34;: { \u0026#34;foreground\u0026#34;: \u0026#34;#6156AB\u0026#34;, \u0026#34;fontStyle\u0026#34;: \u0026#34;italic\u0026#34; } } }, } ","description":"1. 插件 (微软插件全家桶)      Python Pylance : Python LSP Python Debugger : debug 插件 Mypy Type Checker : 类型检查 Pylint : 代码分析 Black Formatter : 格式化插件 isort : import 排序  pip3 install mypy==1.15.0 pip3 install pylint==3.3.4 pip3 install black==24.8.0 pip3 install isort==5.13.2 vscode settings.json\n{ // python \u0026#34;[python]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;ms-python.black-formatter\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;editor.codeActionsOnSave\u0026#34;: { \u0026#34;source.organizeImports\u0026#34;: \u0026#34;explicit\u0026#34; }, }, // isort \u0026#34;isort.args\u0026#34;: [ \u0026#34;--profile\u0026#34;, \u0026#34;black\u0026#34; ], // mypy \u0026#34;mypy-type-checker."},{"id":13,"href":"/books/python/python/grammar/","title":"2. 基础语法","parent":"2. Python 基础","content":"","description":""},{"id":14,"href":"/books/python/python/library/","title":"2. 常用库","parent":"2. Python 基础","content":"","description":""},{"id":15,"href":"/books/python/python/library/file/","title":"2. 文件操作","parent":"2. 常用库","content":" 读取文件 with open 使用 for line in file 读取每一行  def open_file(name: str): \u0026#34;\u0026#34;\u0026#34;Open file and print the content.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: for line in file: print(line, end=\u0026#34;\u0026#34;) file.close() 写入文件  def write_file(name: str, content: str): \u0026#34;\u0026#34;\u0026#34;Write content to file.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, \u0026#34;a\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: file.write(content) file.close() open mode      https://docs.python.org/zh-cn/3.13/tutorial/inputoutput.html#reading-and-writing-files\n  'r' ，表示文件只能读取； 默认值 'w' 表示只能写入（现有同名文件会被 覆盖）； 'a' 表示打开文件并 追加内容，任何写入的数据会自动 添加到文件末尾。 'r+' 表示打开文件进行 读写。  mode 实参是可选的，省略时的默认值为 \u0026lsquo;r\u0026rsquo;。\n","description":"读取文件 with open 使用 for line in file 读取每一行  def open_file(name: str): \u0026#34;\u0026#34;\u0026#34;Open file and print the content.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: for line in file: print(line, end=\u0026#34;\u0026#34;) file.close() 写入文件  def write_file(name: str, content: str): \u0026#34;\u0026#34;\u0026#34;Write content to file.\u0026#34;\u0026#34;\u0026#34; name = os.path.join(dirname, name) with open(name, \u0026#34;a\u0026#34;, encoding=\u0026#34;utf8\u0026#34;) as file: file.write(content) file.close() open mode      https://docs.python.org/zh-cn/3.13/tutorial/inputoutput.html#reading-and-writing-files\n  'r' ，表示文件只能读取； 默认值 'w' 表示只能写入（现有同名文件会被 覆盖）； 'a' 表示打开文件并 追加内容，任何写入的数据会自动 添加到文件末尾。 'r+' 表示打开文件进行 读写。  mode 实参是可选的，省略时的默认值为 \u0026lsquo;r\u0026rsquo;。"},{"id":16,"href":"/books/python/python/types/","title":"2. 类型检查","parent":"2. Python 基础","content":"","description":""},{"id":17,"href":"/books/python/python/library/time/","title":"3. time 时间操作","parent":"2. 常用库","content":"","description":""},{"id":18,"href":"/books/python/python/grammar/controlflow/","title":"3. 流程控制","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html\n 1. if\u0026hellip;else     if ... elif ... else\n复合条件: and, or\nif a \u0026gt; 0 and a \u0026lt;= 40: print(\u0026#34;40 \u0026gt; a \u0026gt; 0\u0026#34;) elif a \u0026gt; 40: print(\u0026#34;a \u0026gt; 40\u0026#34;) else: print(\u0026#34;a \u0026lt; 0\u0026#34;) 2. for in      for in list  words = [\u0026#39;cat\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;defenestrate\u0026#39;] for w in words: print(w, len(w))  for in dict\n  使用 copy() 生成一个副本， 避免 源 被修改后造成数据污染。\n  使用 item() 生成一个可迭代对象\n  # 创建示例多项集 users = {\u0026#39;Hans\u0026#39;: \u0026#39;active\u0026#39;, \u0026#39;Éléonore\u0026#39;: \u0026#39;inactive\u0026#39;, \u0026#39;景太郎\u0026#39;: \u0026#39;active\u0026#39;} # 策略：迭代一个副本 # key =\u0026gt; user # value =\u0026gt; status for user, status in users.copy().items(): if status == \u0026#39;inactive\u0026#39;: del users[user] # 策略：创建一个新多项集 active_users = {} for user, status in users.items(): if status == \u0026#39;active\u0026#39;: active_users[user] = status 3. for/while \u0026hellip; else      在 for 或 while 循环中 break 语句可能对应一个 else 子句。 如果循环在未执行 break 的情况下结束，else 子句将会执行。 必须配合 break 使用。  4. match\u0026hellip;case      https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n  match 不支持匹配多个条件语句 case, 遇到第一个匹配直接返回。 默认值 使用 下划线 _  def http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _: return \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34;  更复杂的匹配规则: https://peps.python.org/pep-0636/\n 6. 生成可迭代对象     一些函数可以生成 可迭代对象， 并配合 for..in 使用。\n6.1. range(n)     range 可以将一个数字快速生成可迭代对象。\nfor i in range(10): print(i) 6.2. enumerate(list)     enumerate 可以将 list 生成一个字典对象， key 为数组索引。\nnames = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;] for i, name in enumerate(names): print(i, name) # 0 Alice # 1 Bob # 2 Charlie ","description":"https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html\n 1. if\u0026hellip;else     if ... elif ... else\n复合条件: and, or\nif a \u0026gt; 0 and a \u0026lt;= 40: print(\u0026#34;40 \u0026gt; a \u0026gt; 0\u0026#34;) elif a \u0026gt; 40: print(\u0026#34;a \u0026gt; 40\u0026#34;) else: print(\u0026#34;a \u0026lt; 0\u0026#34;) 2. for in      for in list  words = [\u0026#39;cat\u0026#39;, \u0026#39;window\u0026#39;, \u0026#39;defenestrate\u0026#39;] for w in words: print(w, len(w))  for in dict\n  使用 copy() 生成一个副本， 避免 源 被修改后造成数据污染。"},{"id":19,"href":"/books/python/python/library/json-yaml/","title":"4. json 和 yaml","parent":"2. 常用库","content":"1. json      json.dumps() 将 结构体 转换为 字符串 json.loads() 将 字符串 转换为 结构体  直接使用 print 打印结果看不出差别，\n[\u0026quot;zhangsan\u0026quot;, \u0026quot;lisi\u0026quot;, \u0026quot;wangwu\u0026quot;] ['zhangsan', 'lisi', 'wangwu'] 因此使用 instanceof 进行类型判断\nimport json users = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] users_dumps = json.dumps(users) # struct -\u0026gt; string print(users_dumps) print(isinstance(users_dumps, str)) # True users_loads = json.loads(users_dumps) # string -\u0026gt; struct  print(users_loads) print(isinstance(users_loads, list)) # True 2. yaml       pypi: https://pypi.org/project/PyYAML/ doc: https://pyyaml.org/wiki/PyYAMLDocumentation   yaml 并不是标准库， 需要额外安装 PyYAML\npip3 install PyYAML pip3 install types-PyYAML  虽然安装包的名字是 pyyaml， 但是使用的时候是 yaml yaml.safe_load() 解析 字符串 为 结构体。 yaml.safe_dump() 反之。  info = \u0026#34;\u0026#34;\u0026#34; name: tangx age: 20 address: contry: China city: Beijing \u0026#34;\u0026#34;\u0026#34; cfg = yaml.safe_load(info) print(cfg) cfg_dumps = yaml.safe_dump(cfg) print(cfg_dumps) 2.2. 指定 loader 和 dumper     也可以指定 Loader 和 Dumper 作为参数传递给 load() 和 dump()\nimport yaml cfg2 = yaml.load(info, Loader=yaml.SafeLoader) cfg2_dumps = yaml.dump(cfg2, Dumper=yaml.SafeDumper)  https://typonotes.com/posts/2024/11/21/python-config-pyyaml/\n 2.3. yaml 的类型问题     如果使用了 Mypy 帮助类型检查， 需要额外安装类型库\npip3 install types-PyYAML 否则会报错\n ","description":"1. json      json.dumps() 将 结构体 转换为 字符串 json.loads() 将 字符串 转换为 结构体  直接使用 print 打印结果看不出差别，\n[\u0026quot;zhangsan\u0026quot;, \u0026quot;lisi\u0026quot;, \u0026quot;wangwu\u0026quot;] ['zhangsan', 'lisi', 'wangwu'] 因此使用 instanceof 进行类型判断\nimport json users = [\u0026#34;zhangsan\u0026#34;, \u0026#34;lisi\u0026#34;, \u0026#34;wangwu\u0026#34;] users_dumps = json.dumps(users) # struct -\u0026gt; string print(users_dumps) print(isinstance(users_dumps, str)) # True users_loads = json.loads(users_dumps) # string -\u0026gt; struct  print(users_loads) print(isinstance(users_loads, list)) # True 2. yaml       pypi: https://pypi."},{"id":20,"href":"/books/python/python/grammar/function/","title":"4. 函数定义","parent":"2. 基础语法","content":" https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n 1. 定义函数      def 关键字 -\u0026gt; 指定返回值  -\u0026gt; xx : 一个返回值 -\u0026gt; tuple[xx, yy] : 多个返回值 -\u0026gt; None 或 省略 : 无返回值    def hello(): print(\u0026#34;Hello Python\u0026#34;) def hi() -\u0026gt; None: print(\u0026#34;Hello Python\u0026#34;) def add(a: int, b: int) -\u0026gt; int: return a + b def calc(a: int, b: int) -\u0026gt; tuple[int, int]: return a + b, a - b 2. 参数      name 比选参数 age 默认参数， 可选参数。  def hello(name: str, age: int = 20): print(f\u0026#34;Hello {name}, you are {age}years old.\u0026#34;) hello(\u0026#34;Alice\u0026#34;, 30) hello(\u0026#34;Bob\u0026#34;) # Hello Alice, you are 30 years old. # Hello Bob, you are 20 years old. 3. 可变参数 / 解构参数       *arg : 数组/元组参数\n  **kwarg : 字典参数\n  在 形参 的时候使用， 接受 对应类型定义参数的时候\n  def concat(*args, sep=\u0026#34;/\u0026#34;): print(sep.join(args)) concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;) # earth/mars/venus concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;, sep=\u0026#34;.\u0026#34;) # earth.mars.venus 在 实参 的时候使用， 解构 传递对应类型的参数  数组或元组\nlist(range(3, 6)) # 附带两个参数的正常调用 # [3, 4, 5] args = [3, 6] list(range(*args)) # 附带从一个列表解包的参数的调用 # [3, 4, 5] 字典\ndef hello(name, age=20): print(f\u0026#34;Hello {name}, you are {age}years old.\u0026#34;) user = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} hello(**user) # Hello Alice, you are 30 years old. ","description":"https://docs.python.org/zh-cn/3.13/tutorial/controlflow.html#defining-functions\n 1. 定义函数      def 关键字 -\u0026gt; 指定返回值  -\u0026gt; xx : 一个返回值 -\u0026gt; tuple[xx, yy] : 多个返回值 -\u0026gt; None 或 省略 : 无返回值    def hello(): print(\u0026#34;Hello Python\u0026#34;) def hi() -\u0026gt; None: print(\u0026#34;Hello Python\u0026#34;) def add(a: int, b: int) -\u0026gt; int: return a + b def calc(a: int, b: int) -\u0026gt; tuple[int, int]: return a + b, a - b 2. 参数      name 比选参数 age 默认参数， 可选参数。  def hello(name: str, age: int = 20): print(f\u0026#34;Hello {name}, you are {age}years old."},{"id":21,"href":"/books/python/advanced/","title":"90. 更上一层楼","parent":"","content":"","description":""},{"id":22,"href":"/books/python/tags/","title":"Tags","parent":"","content":"","description":""}]
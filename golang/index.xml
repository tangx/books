<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>《Shell 转 Go》</title>
    <link>https://typonotes.com/books/golang/</link>
    <description>Recent content on 《Shell 转 Go》</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01. 上下文 context</title>
      <link>https://typonotes.com/books/golang/go-features/context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/context/</guid>
      <description></description>
    </item>
    
    <item>
      <title>01. 变量声明</title>
      <link>https://typonotes.com/books/golang/shell-to-go/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/variable/</guid>
      <description>变量声明 Shell 声明变量 在 Shell 中， 变量声明通常有两种方式
通过 declare 进行变量声明， 并赋值。 省略 declare 进行变量声明。 # 方式1 declare abc=&amp;#34;abc&amp;#34; declare abc_123=123 # 方式2 abc=&amp;#34;abc&amp;#34; abc_123=123 事实上， declare 的用法还是很复杂的， 更多可以参考: https://www.runoob.com/linux/linux-comm-declare.html
Go 声明变量 在 Go 中， 也有两种方式
通过 var 关键字定义， 这种方式可以在 任意位置 定义变量。 省略 var 后， 可以使用 := 进行变量声明。 但是这种方式只能在 代码块 中使用， 可以简单的理解为 只能在函数中使用。 var abc int8 = 100 // 指定 abc 的类型是 int8 var def = 100 // 推定类型为 int func demo() { a1 := 100 var a2 = 100 fmt.</description>
    </item>
    
    <item>
      <title>01. 条件语句 (if else)</title>
      <link>https://typonotes.com/books/golang/shell-to-go/process-control/if-else/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/process-control/if-else/</guid>
      <description>Shell function abc() { n=$1 if [ $n -gt 100 ]; then { # 括号可有可无 echo &amp;#34;无效&amp;#34; } elif [ $n -gt 90 ]; then echo &amp;#34;优秀&amp;#34; else { echo &amp;#34;一般&amp;#34; } fi } 在 Shell 中，
if-else-fi 是通过关键字约束 语句块 边界的。 大括号 {} 可有可无， 但是最好还是带上， 增强可读性。 判断条件使用 方括号 [ ] 或 [[ ]] 定义。 Go func if_else(n int) { if n &amp;gt;= 100 || n &amp;lt;= -1 { fmt.Println(&amp;#34;无效&amp;#34;) } else if n &amp;gt; 90 { fmt.</description>
    </item>
    
    <item>
      <title>01. 环境变量操作</title>
      <link>https://typonotes.com/books/golang/daily-notes/environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/daily-notes/environment/</guid>
      <description>一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://typonotes.com/posts/2021/09/06/golang-os-env-operation/
golang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。
所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。
golang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中
golang程序 在 复制了开始运行的那一瞬间的当前环境所有变量， 之后的父进程中的变量变化不再影响 golang 程序。 golang 程序对环境变量的所有操作，都是在自身的子进程中，因此 只会影响 golang 程序本身。 go 语言中没有类似 bash 中的 export 的操作。 但是可以通过 os.Setenv 设置环境变量。 环境变量操作方法 1. os.Setenv(&amp;quot;key&amp;quot;,&amp;quot;val&amp;quot;) 创建一个环境变量
2. os.Unsetenv(&amp;quot;key&amp;quot;) 取消一个变量
3. val=os.Getenv(&amp;quot;key&amp;quot;) 返回一个变量的值。 如果变量不存在， val 为空字符串。 使用 len(val)==0 无法判断 变量值为空 或者 变量不存在
4. val,ok=os.LookupEnv(&amp;quot;key&amp;quot;) 返回一个变量的值 与 变量是否存在的 bool 结果。</description>
    </item>
    
    <item>
      <title>01. 项目简介</title>
      <link>https://typonotes.com/books/golang/startup/introduce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/startup/introduce/</guid>
      <description></description>
    </item>
    
    <item>
      <title>02. Go 的时区管理</title>
      <link>https://typonotes.com/books/golang/daily-notes/timezone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/daily-notes/timezone/</guid>
      <description>这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://typonotes.com/posts/2023/01/09/golang-timezone-issue/
Golang 中一些不太注意的时区问题
1. time/tzdata 库 Golang 内置的一个时区文件。
可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则 不应该 导入该文件。 导入该文件后， 程序会增加 450KB 大小。 import ( _ &amp;#34;time/tzdata&amp;#34; ) 在老版本（1.15）以前并不包含时区信息， 通常会在容器化的时候单独处理时区问题。
FROM golang:alpine as build RUN apk --no-cache add tzdata WORKDIR /app ADD . . RUN CGO_ENABLED=0 GOOS=linux go build -o myapp FROM scratch as final COPY --from=build /app/myapp .</description>
    </item>
    
    <item>
      <title>02. 下载安装与环境配置</title>
      <link>https://typonotes.com/books/golang/startup/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/startup/install/</guid>
      <description>下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。
通常我会选择压缩包， 然后解压到所需要安装的目录。
例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz
cd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。</description>
    </item>
    
    <item>
      <title>02. 函数</title>
      <link>https://typonotes.com/books/golang/shell-to-go/function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/function/</guid>
      <description></description>
    </item>
    
    <item>
      <title>02. 基础数据类型</title>
      <link>https://typonotes.com/books/golang/shell-to-go/basic-type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/basic-type/</guid>
      <description></description>
    </item>
    
    <item>
      <title>02. 循环语句 (for)</title>
      <link>https://typonotes.com/books/golang/shell-to-go/process-control/for-loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/process-control/for-loops/</guid>
      <description>Go 循环 在 Go 中， 循环只有一个关键字 for， 通过不同的 格式 实现不同的逻辑
基本格式如下
for 默认值; 条件; 计数器 { fmt.Println(&amp;#34;i=&amp;#34;, i) } 以上的 每一个字段都可以省略 。
计数循环 在 shell 中， 通常使用 seq 实现计数循环
for i in $(seq 1 10); do { echo &amp;#34;i = $i&amp;#34; } done 而在 Go 中，
for i := 0; i &amp;lt; 1; i++ { fmt.Println(&amp;#34;i=&amp;#34;, i) } 遍历循环 for name in zhangsan lisi wangwu zhaoliu; do { echo &amp;#34;name = $name&amp;#34; } done 在 Go 中， 需要将对象放入到 切片 中</description>
    </item>
    
    <item>
      <title>02. 结构体 struct</title>
      <link>https://typonotes.com/books/golang/go-features/struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/struct/</guid>
      <description></description>
    </item>
    
    <item>
      <title>03. VSCode配置与插件</title>
      <link>https://typonotes.com/books/golang/startup/vscode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/startup/vscode/</guid>
      <description>VS Code 我更喜欢 gopls， 所以我没用 goland。
下载 到 微软官方 下载 VS Code: https://code.visualstudio.com/ 。
插件 一个好汉三个帮， 一个篱笆三个桩。
VSCode 本身并不是某个特定语言的 IDE。 但是安装了插件 VSCode 就是鸟枪换炮， 爽得飞起。
Go 相关的 必须安装的 Go 插件 , 现在已经交给 Go Team 维护: 非常有用的 Go template 插件， 可以提供 template 的 高亮 和 格式化。 测试使用的 Go Test Explorer， 前期不写单元测试， 也可以不装。 提供代码片段缩写的 Go Snippet， 有用但不多。 可以将 JSON 文件直接转换成结构体的 Paste JSON as Code 通用的 格式化 JSON 的 Json Tools。 展示更方便。 远程开发必备的 Remote - SSH。 可以直接在目标机器（容器）中开发、调试。 一款网络请求的客户端工具 REST Client , 有他就可以不用 Postman 了。 工具 在安装完 最核心的 Go 插件后， VSCode 就会推荐按安装各种开发工具了。</description>
    </item>
    
    <item>
      <title>03. 分支语句 (switch)</title>
      <link>https://typonotes.com/books/golang/shell-to-go/process-control/switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/process-control/switch/</guid>
      <description>在 Shell 中使用 case ... in 做分支语句。
使用 case ... in 作为开始， 使用 esac 作为结尾 使用 xxx ) 格式作为条件分支。 其中 xxx 可以是多个并列条件 使用 ;; 作为语句块结束。 使用 * 作为默认条件语句， 可省略。 case $1 in &amp;#34;n1&amp;#34;) echo &amp;#34;n1&amp;#34; ;; &amp;#34;n2&amp;#34; | &amp;#34;n3&amp;#34;) echo &amp;#34;n2 or n3&amp;#34; ;; *) echo &amp;#34;default&amp;#34; ;; esac 在 Go 中使用 switch 作为分支语句
使用 switch 关键字作为开始 使用 case 关键字作为分支条件。 没有单独的结尾关键字 使用 default 作为 switch n { case 1: fmt.Println(&amp;#34;1&amp;#34;) fallthrough case 2, 3, &amp;#34;a&amp;#34;: fmt.</description>
    </item>
    
    <item>
      <title>03. 接口 interface</title>
      <link>https://typonotes.com/books/golang/go-features/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/interface/</guid>
      <description></description>
    </item>
    
    <item>
      <title>03. 文件路径管理</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/filepath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/filepath/</guid>
      <description></description>
    </item>
    
    <item>
      <title>04. 文件名管理</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/filename/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/filename/</guid>
      <description> 1. 文件名 2. 文件后缀 </description>
    </item>
    
    <item>
      <title>04. 跳转语句(label)</title>
      <link>https://typonotes.com/books/golang/shell-to-go/process-control/label/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/process-control/label/</guid>
      <description>Label 标签在 Shell 中没有。 但在 Go 中却应用广泛。
Label Label 的定义规则为 SomeName: ， 以 : 结尾。
在 Go 使用 Label 必须使用配置关键字 continue, break, goto 的其中一个。
需要注意的是，
continue 和 break 的 Label 可以省略。 continue|break [Label] goto 必须配置 Laebl 使用。 goto Label for/select/switch 和 Label 直接使用 continue/break 的时候， 作用域在 当前代码体 中。 如果配合了 Label 就可以跳出到 当前代码体外。 在配合 for/select/switch 使用时， Label 必须 紧临 他们， 中间不能有任何其他语句。 func continueBreakDemo() { Outer: for m := 1; m &amp;lt; 10; m++ { Inner: for n := 1; n &amp;lt; 10; n++ { fmt.</description>
    </item>
    
    <item>
      <title>04. 通道 channel</title>
      <link>https://typonotes.com/books/golang/go-features/channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/channel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>05. 并发选择语句(select)</title>
      <link>https://typonotes.com/books/golang/shell-to-go/process-control/select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/shell-to-go/process-control/select/</guid>
      <description>select 语句在 Shell 中没有， 但是在 Go 中却是 并发 的根基。
select 在语法上面， 和 switch 相似
使用 case 作为分支入口。 使用 default 作为默认语句。 不同的是，
select 没有条件语句 func selectGrammar(ctx context.Context) { channel := make(chan int, 10) value := 100 select { case &amp;lt;-ctx.Done(): // 执行的代码 case &amp;lt;-time.After(10 * time.Second): // 执行的代码 case val := &amp;lt;-channel: fmt.Println(val) // 执行的代码 case channel &amp;lt;- value: // 执行代码 default: // 所有通道都没有准备好，执行的代码 } } 每个 case 语句都必须是一个通道(channel)。 常见的通道包括以下: ctx.Done。 time.</description>
    </item>
    
    <item>
      <title>05. 泛型</title>
      <link>https://typonotes.com/books/golang/go-features/generic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/generic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>06. 错误处理(error)</title>
      <link>https://typonotes.com/books/golang/go-features/error-operation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/error-operation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>07. defer</title>
      <link>https://typonotes.com/books/golang/go-features/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/defer/</guid>
      <description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域
简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。
从细节来了， 还需要注意
变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。
func Test_Demo(t *testing.T) { i := 10 j := hello(&amp;amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的</description>
    </item>
    
    <item>
      <title>08. panic and recover</title>
      <link>https://typonotes.com/books/golang/go-features/panic-recover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/panic-recover/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1. 参数绑定与交叉编译</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/01-cobra-sample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/01-cobra-sample/</guid>
      <description>作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1.</description>
    </item>
    
    <item>
      <title>2. 配置文件读取与写入</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/02-json-yaml-config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/02-json-yaml-config/</guid>
      <description>作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下
# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果
{ &amp;#34;name&amp;#34;:&amp;#34;zhangsan&amp;#34;, &amp;#34;age&amp;#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。
这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。
var ( name string age int ) func init() { root.Flags().StringVarP(&amp;amp;name, &amp;#34;name&amp;#34;, &amp;#34;n&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;名字&amp;#34;) root.Flags().IntVarP(&amp;amp;age, &amp;#34;age&amp;#34;, &amp;#34;a&amp;#34;, 20, &amp;#34;名字&amp;#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。</description>
    </item>
    
    <item>
      <title>3. 交互式命令</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/03-interactive-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/03-interactive-command/</guid>
      <description>原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/
本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案
DevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/
作业: cobra - 03 交互式命令 要求:
使用 https://github.com/spf13/cobra 实现命令工具
使用 https://github.com/go-survey/survey 实现交互式命令
实现 Demo 效果
除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下
为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。
解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。
关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers
话说回来， 虽然 github 仓库地址是 https://github.</description>
    </item>
    
    <item>
      <title>4. 项目的目录结构</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/04-layout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/04-layout/</guid>
      <description>Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。
这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。
另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。
例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是
/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。
internal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。
首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo
代码目录树如下
限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制</description>
    </item>
    
    <item>
      <title>5. 子命令与Cobra命令树的实现</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/05-1-command-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/05-1-command-tree/</guid>
      <description>cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。
var root = &amp;amp;cobra.Command{} var child = &amp;amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。
cobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。
删除多余的结构， cobra 节点 就是下面这样的。
type Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。
// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds .</description>
    </item>
    
    <item>
      <title>5.2 gin 路由树的实现(扩展)</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/05-2-gin-router-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/05-2-gin-router-tree/</guid>
      <description>gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。
// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return &amp;amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，</description>
    </item>
    
    <item>
      <title>6. 持久化命令与Go引用类型的使用</title>
      <link>https://typonotes.com/books/golang/cobra-in-action/06-persistent-flag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/cobra-in-action/06-persistent-flag/</guid>
      <description>DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。
状态: 未更新
原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/
嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。
下面这段代码是是使用时的定义。
var root = &amp;amp;cobra.Command{ Use: &amp;#34;root&amp;#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(&amp;#34;PersistentPreRun in root&amp;#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root.</description>
    </item>
    
    <item>
      <title>cut 切割字符串</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/cut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/cut/</guid>
      <description>cut 有几个参数， 分别提供了不同的用法。
1. -b 获取字符或字符串 $ echo abcdefg |cut -b 1,5 ae $ echo abcdefg |cut -b 1-5 abcde 这种情况， 相当于在 Go 中的切片操作
func CutB() { s := &amp;#34;abcdefg&amp;#34; b1 := s[0] // (1) var b1 byte fmt.Println(string(b1)) // cut -b 1 fmt.Println(s[0:5]) // (2) cut -b 1-5 } 这里需要注意的是
如果对字符串取 1个值， 则取出来的值是 byte 类型。 例如这里的 b1 Go 中的索引是 从 0 开始 计数； 且属于 左闭又开 模式， 即 左包含右不包含。 2. -d 指定分隔符， -f 指定分段位置 在使用 -d 的时候， 可以指定 分割符。</description>
    </item>
    
    <item>
      <title>ls 查看目录内容</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/ls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/ls/</guid>
      <description>在 Linux 中， 使用 ls 命令查看文件夹内容
ls /path/2/folder 在 Go 中， 使用 os.ReadDir 获取文件夹中的内容。
func OsWalk(name string) { entries, err := os.ReadDir(name) if err != nil { panic(err) } for _, entry := range entries { if entry.IsDir() { fmt.Printf(&amp;#34;%s 是文件夹\n&amp;#34;, entry.Name()) } fmt.Printf(&amp;#34;%s 是文件\n&amp;#34;, entry.Name()) } } </description>
    </item>
    
    <item>
      <title>md5sum 计算md5值</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/md5sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/md5sum/</guid>
      <description>在 Linux 中， 使用 MD5 值作为唯一性校验应该是最基本的了。
# 字符串 echo &amp;#34;abc&amp;#34; | md5sum # 文件 md5sum /path/2/file.txt 计算字符串 md5 计算字符串 md5 值相对简单， 直接使用标准库中的 md5 库就可以了
func MustMd5(s string) string { h := md5.New() _, err := io.WriteString(h, s) if err != nil { panic(err) } return fmt.Sprintf(&amp;#34;%x&amp;#34;, h.Sum(nil)) } 计算文件 md5 计算文件的就稍微多一个步骤， 就是读取文件内容。 读取完了， 直接丢到上一个函数中就可以了。
func MustMd5File(name string) string { data, err := os.ReadFile(name) if err != nil { panic(err) } return MustMd5(string(data)) } </description>
    </item>
    
    <item>
      <title>mkdir 创建目录</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/mkdir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/mkdir/</guid>
      <description>在 Linux 中， 创建目录使用 mkdir， 如果要多级创建使用 mkdir -p
mkdir -p /path mkdir -p /path/to/abc 在 Go 中， 有对应的标准库 os.Mkdir
func Mkdir() { os.Mkdir(&amp;#34;path&amp;#34;, os.ModePerm) // 创建一级目录 os.MkdirAll(&amp;#34;path/to/abc&amp;#34;, os.ModePerm) // 创建多级目录 } 在创建的时候， 需要指定目录权限， 通常使用 os.ModePerm 就可以了。</description>
    </item>
    
    <item>
      <title>random</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/random/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/random/</guid>
      <description></description>
    </item>
    
    <item>
      <title>sleep 时间等待</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/sleep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/sleep/</guid>
      <description>时间等待， 让程序 阻塞 一段时间
在 Shell 中 在 Shell 中使用 sleep n ， n 的默认单位 秒
sleep 2 在 Go 中 在 Go 中， 对应使用 time.Sleep(n) 方法。但是需要注意的是， n 的默认单位是 毫秒。
time.Sleep(200) 如果要实现如果实现 秒 级别等待，
可以将数字扩大 1000 倍， n * 1000 可以使用单位 n * time.Second time.Sleep(2 * 1000) time.Sleep(2 * time.Second) 常见单位 const ( Nanosecond Duration = 1 // 纳秒 Microsecond = 1000 * Nanosecond // 微秒 Millisecond = 1000 * Microsecond // 毫秒 Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) </description>
    </item>
    
    <item>
      <title>tr 大小写转换</title>
      <link>https://typonotes.com/books/golang/linux-go-snippet/tr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/linux-go-snippet/tr/</guid>
      <description>大小写转换 tr 其中一个最常见的， 是 大小写 的转换。
echo &amp;#34;abcDefg&amp;#34; | tr &amp;#39;a-z&amp;#39; &amp;#39;A-Z&amp;#39; 对于这个使用 Go 中对应的标准库 strings
func TrDemo() { s1 := strings.ToLower(&amp;#34;abcDEFg&amp;#34;) // 转小写 s2 := strings.ToUpper(&amp;#34;abcDEFg&amp;#34;) // 转大写 fmt.Println(s1, s2) } 删除字符 使用 tr -d 删除出现的字符
echo &amp;#34;abcabcabc&amp;#34; | tr -d &amp;#34;ac&amp;#34; 这种情况下， 可以使用 strings.NewReplacer 创建自己的过滤器
func TrDeleteDemo(t *testing.T) { delAbc := strings.NewReplacer(&amp;#34;a&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;&amp;#34;) ret := delAbc.Replace(&amp;#34;abcabcabc&amp;#34;) fmt.Println(ret) } 其中, NewReplacer 的参数必须为双数， 两个一组(old -&amp;gt; new)。 例如这里的就是 a -&amp;gt; 空, c -&amp;gt; 空， 也就是删除的意思。</description>
    </item>
    
  </channel>
</rss>

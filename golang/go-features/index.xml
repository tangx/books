<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>03. Go 特性语法 on 《Shell 转 Go》</title>
    <link>https://typonotes.com/books/golang/go-features/</link>
    <description>Recent content in 03. Go 特性语法 on 《Shell 转 Go》</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/golang/go-features/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01. 结构体 Struct</title>
      <link>https://typonotes.com/books/golang/go-features/struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/struct/</guid>
      <description></description>
    </item>
    
    <item>
      <title>03. Golang 接口(interface)</title>
      <link>https://typonotes.com/books/golang/go-features/golang-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/golang-interface/</guid>
      <description>Golang 接口(interface) 简介和入门使用 上下文 interface 应该是 Go语言 中一个极其重要的 基石 概念了。
这里有一篇 Go 语言设计与实现 - 接口 interface ， 是目前我学习的资料中 完成度 和 友善度 都很高的一篇文章。
在 go v1.18 中， interface 有了一个别名 any。 所以在说 interface 和 any 的时候， 其实说的是相同的东西。
interface 的使用场景到处都是。 还记得我们之前说的 JSON 和 YAML 的配置文件处理吗？
// json.Marshal func Marshal(v any) ([]byte, error) { // .... } 看完文章， 你至少应该知道
什么是 鸭式对象 ？ 怎么使用 接口断言 ？ 鸭式对象 先来说说 鸭式对象: 叫的像鸭子， 走路像鸭子， 那它就是鸭子。
我们对鸭子下一个定义， 1. 发出嘎嘎的叫声， 2.</description>
    </item>
    
    <item>
      <title>04. 通道 Channel</title>
      <link>https://typonotes.com/books/golang/go-features/channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/channel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>05. 泛型</title>
      <link>https://typonotes.com/books/golang/go-features/generic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/generic/</guid>
      <description></description>
    </item>
    
    <item>
      <title>06. 错误处理(error)</title>
      <link>https://typonotes.com/books/golang/go-features/error-operation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/error-operation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>07. defer</title>
      <link>https://typonotes.com/books/golang/go-features/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/defer/</guid>
      <description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域
简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。
从细节来了， 还需要注意
变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数发生了 panic 会怎样 ？ 真题测试 以下这是 go语言爱好者 97 期的一道题目。 要求很简单， 代码执行 i, j 的值分别是什么。
func Test_Demo(t *testing.T) { i := 10 j := hello(&amp;amp;i) fmt.Println(i, j) } func hello(i *int) int { defer func() { *i = 19 }() return *i } 这道题虽然代码少， 但是考点还是蛮多的</description>
    </item>
    
    <item>
      <title>08. panic and recover</title>
      <link>https://typonotes.com/books/golang/go-features/panic-recover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://typonotes.com/books/golang/go-features/panic-recover/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>

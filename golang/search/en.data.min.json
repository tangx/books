[{"id":0,"href":"/books/golang/","title":"","parent":"","content":" golang 学习笔记 ","description":" golang 学习笔记 "},{"id":1,"href":"/books/golang/cobra-in-action/01-cobra-sample/","title":"1. 参数绑定与交叉编译","parent":"Cobra-in-action","content":" 作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1. 安装依赖包 $ go get -u github.com/spf13/cobra 2. 创建命令 var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, // 命令名字 Short: \u0026#34;打招呼\u0026#34;, // 短介绍 Run: func(cmd *cobra.Command, args []string) { // 运行函数 greeting(name, age) }, } 3. 指定参数 定义了变量作为参数接受者。 使用 init 函数， 在程序初始化的时候， 传递参数值。 参数接受者 指针类型 参数名称， 字符串类型 短参数名称， 字符串类型， 但只接受一个参数 默认值， 具体类型 参数描述， 字符串类型 var ( name = \u0026#34;\u0026#34; age = 0 ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;姓名\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;\u0026#34;, 20, \u0026#34;年龄\u0026#34;) } 4. 调用执行 greeting 是程序实际执行逻辑， 及执行逻辑入口。 在 root 的 Run 中调用 执行逻辑入口。 在 main 中调用 root 的执行函数 Execute() func greeting(name string, age int) { fmt.Printf(\u0026#34;%s 你好， 今年 %d 岁\\n\u0026#34;, name, age) } var root = \u0026amp;cobra.Command{ Use: \u0026#34;greeting\u0026#34;, Short: \u0026#34;打招呼\u0026#34;, Run: func(cmd *cobra.Command, args []string) { greeting(name, age) // 2. root 命令调用 greeting 业务 }, } func main() { err := root.Execute() // 3. main 调用 root 命令 if err != nil { log.Fatal(err) } } 4. 使用 Makefile 进行编译管理 使用 GOOS 和 GOARCH 设置环境变量命令。 使用 build 命令， 使用进行 当前系统环境 的编译 并且编译文件命名包含系统信息。 使用 buildx 命令， 实现 交叉编译 使用 clean 命令清空编译结果。 ## 默认变量， 获取当前 go 的环境变量 GOOS ?= $(shell go env GOOS) GOARCH ?= $(shell go env GOARCH) ## build 在指定环境变异 build: go build -o out/greeting-$(GOOS)-$(GOARCH) . ## 通过指定环境变量， 执行交叉编译 buildx: GOOS=linux GOARCH=amd64 make build GOOS=linux GOARCH=arm64 make build GOOS=darwin GOARCH=amd64 make build GOOS=darwin GOARCH=arm64 make build ## 清理编译结果 clean: rm -rf out/ 一个最基本命令结构就这样完成了， 是不是很简单？\n","description":"作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他平台的二进制文件 -rwxr-xr-x 1 devopscamp staff 4220672 Jan 13 15:35 greeting-darwin-amd64 -rwxr-xr-x 1 devopscamp staff 4203442 Jan 13 15:35 greeting-darwin-arm64 -rwxr-xr-x 1 devopscamp staff 4215010 Jan 13 15:35 greeting-linux-amd64 -rwxr-xr-x 1 devopscamp staff 4157892 Jan 13 15:35 greeting-linux-arm64 执行输出效果如下 $ ./out/greeting-darwin-arm64 你好, 今年 20 岁 $ ./out/greeting-darwin-arm64 --age 30 --name zhangsan zhangsan 你好, 今年 30 岁 解题过程 1."},{"id":2,"href":"/books/golang/chapter01/01-introduce/","title":"1. 项目简介","parent":"Chapter01","content":"","description":""},{"id":3,"href":"/books/golang/chapter01/02-install/","title":"2. 下载安装与环境配置","parent":"Chapter01","content":" 下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。\nexport GOPROXY=\u0026#34;https://goproxy.cn\u0026#34; export GOROOT=\u0026#34;/usr/local/go\u0026#34; export GOPATH=\u0026#34;/data/gopath\u0026#34; export PATH=\u0026#34;$GOROOT/bin:$GOPATH/bin:$PATH\u0026#34; 执行 go version 命令测试结果。\n$ go version go version go1.19.6 darwin/amd64 关于Go版本的选择 我会选择使用 次新版本(当前为 v1.19.z) ， 并随时保持更新。 当 最新版本(当前为 1.20.z) 的 z 编号 不小于5 （即 1.20.5）的时候， 才会选择升级到最新版本。 个人意见， 仅供参考。\nVSCode 安装和插件 ","description":"下载和安装 前往 官网Go下载地址 页面下载与自己操作系统对应二进制文件。\n通常我会选择压缩包， 然后解压到所需要安装的目录。\n例如， 我是 mac 的 intel 系统， go1.19.6.darwin-amd64.tar.gz\ncd /tmp wget -c https://go.dev/dl/go1.19.6.darwin-amd64.tar.gz sudo tar xf go1.19.6.darwin-amd64.tar.gz -C /usr/local 配置环境变量 GOPROXY: Go代理地址， 通常使用 https://goproxy.cn 或 https://goproxy.io GOROOT: Go 二进制的位置, 即我们上面解压目录的 /usr/local/go GOPATH: 这个是我们项目代码的位置， 有了 go mod 之后 不是绝对的了 使用 go install 后， 编译的二进制会默认在 $GOPATH/bin/ 使用 go get 下载的所有库文件在 $GOPATH/pkg/mod/ 中 可以直接 go mod init， 如果项目在 $GOPATH/src/ 中， 会默认以相对目录配置 module 路径。 对于 Mac 和 Linux 系统， 设置环境变量。 配置到 /etc/profile 中。"},{"id":4,"href":"/books/golang/cobra-in-action/02-json-yaml-config/","title":"2. 配置文件读取与写入","parent":"Cobra-in-action","content":" 作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。\n配置文件 最常用 的的配置文件类型就是 YAML 和 JSON。 除此之外还有 toml, xml, ini 等， 这些类型的配置文件可以在实际碰到的时候去学习掌握， 大差不差。\n通常 解析 和 映射 方法名称分别为 Marshal 和 Unmarshal\nMarshal(v any) ([]byte, error) 将结构体 解析 成 []byte 类型。 Unmarshal(data []byte, v any) error 将 []byte 映射 到结构体中。 这里的 v 需要是 指针类型 但有些库在名字上可能具有一定变种，通常也有迹可循。\nMarshalJSON MarshalYAMl 不同库 对应的的 方法名称 和 实现逻辑 也不尽相同， 如果凭经验使用遇到了问题， 一定要去看看官网文档。\n最基本常用的解析库\njson: encoding/json yaml: gopkg.in/yaml.v3, gopkg.in/yaml.v2 v2 和 v3 有区别， 自己研究。 解题过程 1. 指定配置文件参数 由于我们的实际 参数/变量 通过配置文件管理了， 因此我们就需要指定一个配置文件参数。\nvar config string func init() { root.Flags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;config.yml\u0026#34;, \u0026#34;配置文件\u0026#34;) } 有了上一篇作业的经验， 这个应该就很简单。\n2. 读取配置 我们定义了一个名为 Person 的结构体， 包含两个字段 Name 和 Age， 用于接受参数/变量。\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34;` } 我们在字段后面， 使用 tag 进行了信息补充， 提供 yaml 解析的行为参数。\n图片是之前 struct 的截图， 其中\n（1） 是字段名称 （2-4） 是 tag 内容。 （2） 是 tag name， 解析库依赖此字段进行判定。 （3-4） 是 tag value, 本质上是 字符串。 例如这里 name 和 omitempty 使用 分隔符, 进行分割。 不同的库的分隔符有所不同， 例如 gorm 使用的 分号;。 （3） 在这里对应的是 映射 的字段名称。 例如 yaml 文件中的 name 对应结构体中的 Name。 这里 name 也可以是其他值， 例如 MyName， 那么就会在 yaml文件中找对应的 MyName 字段。 （4） omitempty 是 yaml 支持的操作符， 同时还支持 flow, inline。 具体功能描述可以参考 https://pkg.go.dev/gopkg.in/yaml.v3#pkg-functions func readConfig(name string) *Person { person := \u0026amp;Person{} // 1. 读取文件 b, err := os.ReadFile(config) if err != nil { panic(err) } // 2. 绑定参数 err2 := yaml.Unmarshal(b, person) if err2 != nil { panic(err) } return person } 初始化 person 指针对象， 其底层类型为 Person 结构体。 在 readConfig 函数中， 我们使用 os.ReadFile 读取文件内容。 并通过 yaml.Unmarshal 将数据映射到 person 实例中。 需要 注意的是， person 所在的参数未知， 必须是 指针 对象， 否则反射无法保存数据到 内存 中。 保存文件为 json 把配置信息保存为 json 文件， 就是之前 yaml 的反操作。\n// dumpConfig 保存文件 func dumpConfig(person *Person) { // 将结构体解析成 []byte b, err := json.Marshal(person) if err != nil { panic(err) } // os.ModePerm =\u0026gt; folder 755, file 644 err2 := os.WriteFile(\u0026#34;config.json\u0026#34;, b, os.ModePerm) if err2 != nil { panic(err) } } 使用 json.Marshal 将对象转换成 []byte。 由于是 读取操作， person 所在的参数为止可以是结构体， 也可以是指针。 使用 os.WriteFile 进行文件写入操作。 需要注意的是 os.ModePerm 这个权限， 对于文件夹是 755， 对于文件是 644， 非常的灵活。 {\u0026#34;Name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;Age\u0026#34;:2600} 执行后，得到的结果与期望的结果有一点点不同。注意 ，这里的 Name 和 Age 都是大写。\n我们对 Person 结构体稍微做一点改造\ntype Person struct { Name string `yaml:\u0026#34;name,omitempty\u0026#34; json:\u0026#34;name,omitempty\u0026#34;` Age int `yaml:\u0026#34;age,omitempty\u0026#34; json:\u0026#34;age,omitempty\u0026#34;` } 加上 json tag 之后， 得到的结果就与期望一致了。\n{\u0026#34;name\u0026#34;:\u0026#34;zhugeliang\u0026#34;,\u0026#34;age\u0026#34;:2600} 思考题 留一点思考题吧。\n为什么没有设置 json tag 也可以成功保存 json 配置？ 设置了 json tag 之后， json 配置中的字段名字变了， 他们的优先级是什么？ 要怎么 忽略 一个字段？ 答案在官方文档中。\n","description":"作业要求 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --config , -c 配置文件 配置文件如下\n# config.yml name: zhangsan age: 20 将配置文件保存为 JSON 格式 $ cat config.json 输出结果\n{ \u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: 20 } 单个参数绑定的困境 之前我们使用了 单个参数独立绑定 的方式， 为我们的 greeting 应用绑定了 name 和 age 参数。\n这种方式有个很明显的缺点， 如果应用参数的数量较多（比如说几十个） 的时候， 就会出现庞大的参数列表， 可读性 和 维护性 都会变得很差。\nvar ( name string age int ) func init() { root.Flags().StringVarP(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;n\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;名字\u0026#34;) root.Flags().IntVarP(\u0026amp;age, \u0026#34;age\u0026#34;, \u0026#34;a\u0026#34;, 20, \u0026#34;名字\u0026#34;) } 因此在生产中， 我们常常会选择 配置 文件来进行 参数/变量 的管理。 例如作业要求中提到的 YAML 或者 JSON 文件。"},{"id":5,"href":"/books/golang/chapter01/03-vscode/","title":"3. VSCode配置与插件","parent":"Chapter01","content":"","description":""},{"id":6,"href":"/books/golang/cobra-in-action/03-interactive-command/","title":"3. 交互式命令","parent":"Cobra-in-action","content":" 原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github.com/go-survey/survey ， 但安装库需要使用命令\n$ go get -u github.com/AlecAivazis/survey/v2 在 go.mod 第一行中, 也可以看到 module 的名称\nmodule github.com/AlecAivazis/survey/v2 平时在使用的时候， 应该多注意官方文档的 Usage、 exmaple 或者 _test.go 等。\n2. 需要使用的交互组件 survey 提供了很多组件类型以及 Option 参数、 验证器 等功能，非常全面。 在这里简单介绍常用的几种\nInput 组件： 普通输入框， 输入什么就显示什么。 Password 组件： 密码输入框， 输入的内容不直接显示， 使用 * 替代。 Select 组件： 单选框。 MultiSelect 组件： 多选框， 结果为 切片 类型。 Confirm 组件： 确认框， 结果为 布尔 类型。 更多其它组件， 可以参考官方文档。\n3. 代码片段 参考 aliyun 命令行， 我们自己实现的功能需要以下字段。\nAccess Secret ID Access Secret Key Region Language 代码中， 创建了 匿名 struct ， 并创建 实例 赋值给 answers\nanswers := struct { ID string Key string ChinaRegion string `survey:\u0026#34;region\u0026#34;` Language []string }{} 其中 ChinaRegion 字段通过 tag survey:\u0026quot;region\u0026quot; 指定了一个映射名字 region。 回想一下， 这种用法是不是和上一篇配置文件中的 json, yaml 字段的映射名字用法一样？\n另一方面， 我们还准备了一系列问题， 引导用户输入\n// the questions to ask var qs = []*survey.Question{ { // 1. Input 输入框 Name: \u0026#34;id\u0026#34;, Prompt: \u0026amp;survey.Input{ Message: \u0026#34;Access Secret ID: \u0026#34;, }, Validate: survey.Required, }, { // 2. Password 密码输入框 Name: \u0026#34;key\u0026#34;, Prompt: \u0026amp;survey.Password{ Message: \u0026#34;Access Secret Key: \u0026#34;, }, Validate: survey.Required, }, { // 3. Select 单选框 Name: \u0026#34;region\u0026#34;, Prompt: \u0026amp;survey.Select{ Message: \u0026#34;Choose a region:\u0026#34;, Options: []string{\u0026#34;cn-shanghai\u0026#34;, \u0026#34;cn-hangzhou\u0026#34;}, Default: \u0026#34;cn-hangzhou\u0026#34;, }, }, { // 4. MultiSelect 多选框 Name: \u0026#34;language\u0026#34;, Prompt: \u0026amp;survey.MultiSelect{ Message: \u0026#34;Supported Configure Language: \u0026#34;, Options: []string{\u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34;, \u0026#34;jp\u0026#34;}, }, }, } qs 中的 Name 名称与 answers 中的字段名称都是一一对应的。 在 id 和 key 字段， 设置了验证器， 要求 必须提供。 在 region 字段， 设置 cn-hangzhou 为默认值， 虽然在切片中排在第二位。 另外， 我们还使用 Confirm 组件引导用户确认是否将输入内容保存到文件中。 由于 保存确认 并不需要保存到配置文件中， 因此我们将其单独封装在了 confirm 函数中。\nfunc confirm() bool { ok := false // 5. Confirm 确认框 prompt := \u0026amp;survey.Confirm{ Message: \u0026#34;是否保存文件?\u0026#34;, } survey.AskOne(prompt, \u0026amp;ok) return ok } 4. JSON MashralIndent 为了更好的可读性， 这次在保存配置文件的时候， 使用了 MarshalIndent 方法。\n{ \u0026#34;ID\u0026#34;: \u0026#34;AKID-demodemo-adsfasdf\u0026#34;, \u0026#34;Key\u0026#34;: \u0026#34;flasjdflaksdjf\u0026#34;, \u0026#34;ChinaRegion\u0026#34;: \u0026#34;cn-shanghai\u0026#34;, \u0026#34;Language\u0026#34;: [ \u0026#34;zh\u0026#34;, \u0026#34;en\u0026#34; ] } 5. 全局 profile 字段 你可能已经注意到了， 目前所有的代码都在 main 包下面， 并没有 划分目录结构。\nvar profile string 因此定义的 profile 是全局变量， 可以在 任意位置 直接使用。\n但是我们在使用的时候并没有在函数中直接使用， 而是通过 函数参数 的方式传递下去的。 这是我们 刻意 回避直接在 dumpConfig 中直接使用 全局的profile 的。\n关于 目录结构 我们将会在后面的作业中提到。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;aliyunx\u0026#34;, Short: \u0026#34;aliyun 配置中心\u0026#34;, Run: func(cmd *cobra.Command, args []string) { // 1. 使用全局 profile interactive(profile) }, } func interactive(profile string) { // 2. 参数传递 dumpConfig(profile, answers) } func dumpConfig(profile string, answer any) { // 3. 参数传递 name := fmt.Sprintf(\u0026#34;%s.config.json\u0026#34;, profile) err2 := os.WriteFile(name, b, os.ModePerm) if err2 != nil { panic(err2) } } 效果展示 ","description":"原文链接: https://tangx.in/posts/2023/01/26/devopscamp-cobra-interactive-survey/\n本文为 DevOpsCamp 实战训练作业 cobra - 03 配置文件的读取与写入（简单） 的解题答案\nDevoOpsCamp 作业地址： https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra03/\n作业: cobra - 03 交互式命令 要求:\n使用 https://github.com/spf13/cobra 实现命令工具\n使用 https://github.com/go-survey/survey 实现交互式命令\n实现 Demo 效果\n除了官方效果之外， 我还发现了 aliyun 命令行工具在配置账户的时候使用的是 交互式 ， 如下\n为了更好的体现 实战性， 我们将以 aliyun configure --profile 的作为例子， 并进行一些优化。\n解题过程 1. 安装 survey 依赖 这是一个意外收获， survey 库的 Github 地址与 go module 名称不一致。 同时， survey 版本还是 v2 了。\n关于 go module version ， 参考文章： https://go.dev/doc/modules/version-numbers\n话说回来， 虽然 github 仓库地址是 https://github."},{"id":7,"href":"/books/golang/cobra-in-action/04-layout/","title":"4. 项目的目录结构","parent":"Cobra-in-action","content":" Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制\n在 /cmd/appname/cmd/say 访问 pkg/internal/master 时，\n找到与 /pkg 与 /cmd 是相同层级。 但是 /pkg/internal 是子层级， 与 /cmd/appname 是同一层级。 因此属于 远亲， 不能直接调用 /pkg/internal/master 公共方法暴露 但是， 可以通过 私有包的公共方法暴露， 例如上图中的 (3)\n/pkg/hello 与 /pkg/internal 是同级， 且是 近亲， 可以调用。 /pkg/hello 是公共的 /cmd/appname/cmd/say 可以通过调用 /pkg/hello 间接实现调用 master 的逻辑。（ 更多详细信息， 可以阅读 internal 运行机制\n那 internal 是不是就一定不能被访问了呢？ 也不一定， 可以参考 突破限制,访问其它Go package中的私有函数 包命名规范 关于包的命名规范， Go 官方是有明确说明的， 但是 没有强制约束 。\n要求\n短，好记，有意义： bytes, io, os 小写字母。 多个单词使用 连字符（-） 连接， 不要使用 蛇形（下划线） 或者 驼峰： qcloud-cdn-sdk 更多信息， 参考 effective_go\n函数/方法，变量命令 大写开头是公共， 小写开头是私有： 这个就不多说了 命名不要与包名有重复： 假如包名为 bytes， 函数名就不用叫 BytesReader 了， 否则调用起来就是 bytes.BytesReader。 函数名就叫 Reader 就好了， 调用起来就是 bytes.Reader。 命令要有意义： 见名知义。 命名要遵循 驼峰 规则。 循环依赖 这个就不多说了， 学了基础的都应该知道， 相关文章一搜一大把。\n这个是 Go 语言的 强制约束。 换句话说， 不用等到编译， 在写代码的时候 IDE 就会提示你出现错误。\n","description":"Go 项目的目录结构 Go 项目的目录结构， 通常都会参考该项目 Go语言规范/项目结构 - Github 。\n这是一个社区规范， 遵守这个规范， 大家都会很轻松。 但并不是严格的 Go 语言标准， 实际操作中各个公司可能会有自己的标准。\n另外， 在上述的 Github 仓库中可以看到， 所有 目录功能 都只有一层。 这样就意味着在实际使用时我们是可以自由组合。 只要遵守该层的功能约定就可以了。\n例如， 使用 cobra 时， 用于管理命令的 cmd 目录， 位置可以是\n/cmd/appname/cmd # 或 /pkg/cmd/ # 或 /internal/pkg/cmd # 或 /pkg/internal/cmd 关于这个没有必要钻牛角尖， 只要是一群相对固定的维护人员认同的约定， 就可以了。\ninternal 包 internal 包是是特殊的， 也是 Go 语言规范 强制 约束的。\n首先， 它的目录位置不是固定的， 和其他包一样。 其次， 它的访问是受限的， 只有和他有 近亲亲属关系 的路径才能访问。 举个例子， 代码在 https://github.com/tangx-labs/go-internal-demo\n代码目录树如下\n限制访问 在上图中, 其中 (2) 的调用因为没有权限被限制"},{"id":8,"href":"/books/golang/cobra-in-action/05-1-command-tree/","title":"5. 子命令与Cobra命令树的实现","parent":"Cobra-in-action","content":" cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } // 为子命令设置父命令（认亲） cmds[i].parent = c // (1) // 省略 // 添加传入的子命令 c.commands = append(c.commands, x) // (2) } } (1) 在我们可以在任意节点调用 Execute 方法， 这个调用会通过 递归 找到最上层的 根 节点。\nfunc (c *Command) Execute() error { _, err := c.ExecuteC() return err } // ExecuteC executes the command. func (c *Command) ExecuteC() (cmd *Command, err error) { // Regardless of what command execute is called on, run on Root only // 递归寻找最上层 if c.HasParent() { return c.Root().ExecuteC() } } 再来看一次 Command 结构体定义\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } (2) 通过将传入的命令保存到 []*Command 切片中， 实现了命令树的 组合 。\nc.commands = append(c.commands, x) // (2) 且同时 实现了 同一个命令挂载到多个父命令上\nroot.AddCommand(sub1, sub2) // (a) sub1.AddCommand(sub2) // (b) commands 是一个切片， 用于保存 挂载 上来的子命令。 但是， 这里需要注意， 由于 *Command 是指针类型， 意味着在任何修改， 都可能影响其他调用的地方。\n对于 sub2 而言, (a)处父节点是 root。 (b)处父节点是 sub1。 最终父节点是 sub1。 但不影响 sub2 同时是 root 和 sub1 的子命令。\n总体来说， cobra 命令节点 独立而又统一\n","description":"cobra 的子命令 在 cobra 中， 每个 命令 都是独立的。 通过 parent.AddCommand(children) 的形式进行串连。\nvar root = \u0026amp;cobra.Command{} var child = \u0026amp;cobra.Command{} func init() { root.AddCommand(child) } 没了， 应用上就这么多。\ncobra 命令树 如果你用过 gin 的路由树的话， 可能会对 cobra 的命令树实现更为深刻。\n删除多余的结构， cobra 节点 就是下面这样的。\ntype Command struct { // 子命令 commands []*Command // 父命令 parent *Command } 当进行 命令树 组合的时候， 是通过 领养/挂靠 的方式实现的。\n// AddCommand adds one or more commands to this parent command. func (c *Command) AddCommand(cmds ."},{"id":9,"href":"/books/golang/cobra-in-action/05-2-gin-router-tree/","title":"5.2 gin 路由树的实现(扩展)","parent":"Cobra-in-action","content":" gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，\n必须 要传入 子节点 的相对路径 使用私有方法计算出 basePath 的值。 这个特别像怀孕生孩子， 一代接一代。 绝对错不了。 O.o。\ngin 的 RouterGroup 能实现 认亲/挂靠 模式吗？ 肯定可以， 做个变形手术就好了。 这里挖个坑吧。\n","description":"gin 的路由树 与 cobra 相比， gin 的路由树实现就是另外一种方式了， 我称之为 生长。 换句话说， gin 路由的子节点不能独立于父节点 单独 定义。\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix. // For example, all the routes that use a common middleware for authorization could be grouped. func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026amp;RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 从上面代码可以看出来， RouterGroup 是通过 Group 方法实现路由节点 生长 的， 在调用 Group 方法的时候，"},{"id":10,"href":"/books/golang/cobra-in-action/06-persistent-flag/","title":"6. 持久化命令与Go引用类型的使用","parent":"Cobra-in-action","content":" DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root.PersistentFlags().StringVarP(\u0026amp;config, \u0026#34;config\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;~/.config.json\u0026#34;, \u0026#34;配置文件\u0026#34;) } 凡是定义了 Persistent Run(1) 和 Flag(2) 的节点， 其子孙节点都会 继承 这种状态。 这种状态也可以被子孙节点的自定义状态覆盖。\n注意： 这种状态是继承自 其父节点， 而非 上级节点 。\n父节点不是上级节点 这个的问题的发生原因， 还是在 xxx.AddCommand 的时候造成的。 因为 \u0026amp;cobra.Command{} 是指针对象/引用对象， 因此在不同的地方修改是会全局影响的。 这个是基础知识， 也是重要的 坑 点， 需要牢记。\n下面是一个代码案例， 帮助理解。\n案例代码在在 Github: https://github.com/tangx-labs/cobra06-demo\n代码中实现了一个如下图所示的 命令树 结构。 其中 sub2 同时挂载到了 root 和 sub1 节点。\n以下是代码执行结果执行结果， 注意看\n--config 的参数值 PersistentPreRun 的执行结果 sub2 的 Usage 路径， 无论从哪里进入， 都是 root sub1 sub2。 代码执行过程 ./cobra-demo6 # ./cobra-demo6 PersistentPreRun in root Flags: -c, --config string 配置文件 (default \u0026#34;~/.config.json\u0026#34;) ./cobra-demo6 sub1 # ./cobra-demo6 sub1 PersistentPreRun in sub1 Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) ./cobra06-demo sub2 # ./cobra06-demo sub2 # (1) PersistentPreRun in sub1 # (2) Usage: root sub1 sub2 [flags] # (3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) # (4) ./cobra06-demo sub1 sub2 # ./cobra06-demo sub1 sub2 #(1) PersistentPreRun in sub1 #(2) Usage: root sub1 sub2 [flags] #(3) Global Flags: -c, --config string 配置文件 (default \u0026#34;$HOME/.config.json\u0026#34;) #(4) 引用类型回顾 首先， 我们再来回顾一下一下 Cobra Command 的结构体\ntype Command struct { Use string parent *Command\t// 父命令 commands []*Command\t// 子命令 } 可以看到， parent *Command 是指针类型。 这意味着， 在任何地方修改都会影响全局引用。\n这里简单的回顾一下 引用对象。 A, B, C 都指向 指针地址， 而 指针地址 纸箱 真实数据地址。 当因为某个外力修改了 真实数据地址 中的内容的时候， 虽然 A, B, C 都没变化， 但是他们 取 到的东西发生了变化。\n举个例子，\n你去温泉之前寄存物品， 商家会给你一个 手牌（指针地址）， 你拿着手牌将 名贵手表（数据） 放入对应的 100号柜子（真实地址）。 在你泡温泉的时候， 某个人（外力） 打开了柜子， 把你的手表换成了 塑料手表（数据修改）。 等你回来的时候， 虽然你的手牌没变， 但是你打开柜子的时候， 你拿到的不再你期望的东西了。 而正好， 每次执行 xxx.AddCommand(children) 添加子命令的时候， children 节点的 parent 字段都会被修改。\nfunc (c *Command) AddCommand(cmds ...*Command) { for i, x := range cmds { if cmds[i] == c { panic(\u0026#34;Command can\u0026#39;t be a child of itself\u0026#34;) } cmds[i].parent = c // child 的父节点会被修改 // 省略 } } 当一个节点， 重复被假如到其他节点的时候， 会出现这个问题。\ncobra 树实现过程解析 下面， 我们对命令树的实现过程进行拆分。 注意 每个节点分为上下两层， 上层 表示父节点的名称， 下层 表示当前节点。\nparent ---------- node 当执行第一条命令时时候， 此时创建的命令树就有所差异了。 左侧时从 root 开始， 右侧是从 sub1 开始。\n当执行的第二条命令的时候， 都实现了相同结构的命令树（不看父节点差异的话）。\n但仔细分析其内部节点， 可以知道， 相同位置的节点， 其父节点不一样。\n","description":"DevOpsCamp第2期：从 《cobra - 06 持久化命令》 开始聊聊 Go语言 指针类型的使用注意事项 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。\n状态: 未更新\n原文链接: https://typonotes.com/posts/2023/02/19/devopscamp-cobra-06-persistent-run-and-flags/\n嗯， 在 cobra 中提供了一种叫做 Persistent 的 状态， 定向支持 函数 与 参数。\n下面这段代码是是使用时的定义。\nvar root = \u0026amp;cobra.Command{ Use: \u0026#34;root\u0026#34;, // Persistent Run (1) PersistentPreRun: func(cmd *cobra.Command, args []string) { fmt.Println(\u0026#34;PersistentPreRun in root\u0026#34;) }, Run: func(cmd *cobra.Command, args []string) { _ = cmd.Help() }, } var config string func init() { // Persistent Flag (2) root."},{"id":11,"href":"/books/golang/chapter01/","title":"Chapter01","parent":"","content":"","description":""},{"id":12,"href":"/books/golang/cobra-in-action/","title":"Cobra-in-action","parent":"","content":"","description":""},{"id":13,"href":"/books/golang/tags/","title":"Tags","parent":"","content":"","description":""}]
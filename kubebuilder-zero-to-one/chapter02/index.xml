<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chapter02 on Geekdocs</title><link>http://localhost/chapter02/</link><description>Recent content in Chapter02 on Geekdocs</description><generator>Hugo -- gohugo.io</generator><atom:link href="http://localhost/chapter02/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>http://localhost/chapter02/04-filed-validation-by-comment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/04-filed-validation-by-comment/</guid><description>使用注解完整字段值约束 在 /api/v1/redis_types.go 中，使用注解完成字段值约束。
约束条件必须以 //+kubebuilder:validation:&amp;lt;METHOD&amp;gt;:=&amp;lt;VALUE&amp;gt; 为格式， 符号之间 没有空格。 约束条件必须 紧邻 字段， 且在字段上方。 https://book.kubebuilder.io/reference/markers/crd-validation.html
type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` //+kubebuilder:validation:Minimum:=1234 //+kubebuilder:validation:Maximum:=54321 Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 重新编译安装
make install 使用命令查看查看
kg crd redis.myapp.tangx.inSpec:Description:RedisSpec defines the desired state of RedisProperties:Port:Format:int32Maximum:54321Minimum:1234Type:integerReplicas:Type:integerType:object将 /deploy/my-op-redis.</description></item><item><title/><link>http://localhost/chapter02/05-filed-validation-by-webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/05-filed-validation-by-webhook/</guid><description>通过 webhook 进行字段验证 通过 kubebuilder 生成代码 # 创建 api kubebuilder create api --group myapp --version v1 --kind Redis # 创建 api 的 webhook kubebuilder create webhook --group myapp --version v1 --kind Redis --defaulting --programmatic-validation 增加 webhook 条件 在 /api/v1/redis_webhook.go 中增加检查条件。
检查 webhook 被触发有三个条件 Create / Update / Delete 时间节点, 分别对应三个方法。
如下是 创建时检查
func (r *Redis) ValidateCreate() error { redislog.</description></item><item><title/><link>http://localhost/chapter02/06-create-pod-by-redis-operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/06-create-pod-by-redis-operator/</guid><description>使用 Operator 创建并发布一个 Pod 1. 组装 k8s api 创建 pod 创建 /controllers/helper 目录， 这里面的代码实现 k8s Workloads 的创建。 具体实现就是封装 k8s workloads 的 api 对象
// CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, config *appv1.Redis) error { pod := &amp;amp;corev1.Pod{} pod.Name = config.Name pod.Namespace = config.Namespace pod.Spec.Containers = []corev1.Container{ { Name: config.Name, Image: config.Spec.Image, ImagePullPolicy: corev1.PullIfNotPresent, Ports: []corev1.ContainerPort{ { ContainerPort: config.Spec.Port, }, }, }, } // ctx := context.</description></item><item><title/><link>http://localhost/chapter02/07-1-delete-pod-by-redis-OwnerReference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/07-1-delete-pod-by-redis-OwnerReference/</guid><description>使用 OwnerReference 管理 redis operator 创建的 Pod https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/
在上一章的代码可以通过如下命令创建一个 redis 实例， 并随即创建一个 Pod
ka -f deploy/ 但是在使用如下命令删除 redis 实例时， 虽然命令行界面提示删除成功， 但是创建的 Pod 依旧存在。
krm -f deploy/ 其原因是 redis 实例 与 Pod 之间 没有 建立关联关系。
那要如何创建关联关系呢？ 可以参考阅读官方博客， 使用 finalizer 控制删除。
在 Owner Reference 一节中提到了资源的 父子关系 。
根据这个原理， 更新 /controllers/helper/redis_helper.go 的 Pod 创建 API， 加入 OwnerReference 相关的代码。
// CreateRedis 创建 redis pod func CreateRedisPod(ctx context.Context, client client.</description></item><item><title/><link>http://localhost/chapter02/07-2-delete-pod-by-finalizers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/07-2-delete-pod-by-finalizers/</guid><description>使用 finalizers 管理 redis operator 创建的 Pod https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/
上一章使用了 OwnerReference 关联 redis instance 和所创建的 Pod， 这里的删除是通过 k8s 内置的关系处理器处理的。
根据官方博客文档中的阐述， 当一个资源的额 finalizers 没有被清空时， 这个资源将无法被删除。 因此， 本章通过 finalizers
来建立 redis instance 和所创建 pod 的关系， 以及处理删除逻辑 1. 创建 redis instance 与 pod 的关系 在 /controllers/helper/redis_helper.go 通过 Finalizers 管理 Pod
// CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, redis *appv1.Redis) error { isUpdated := false for i := 0; i &amp;lt; redis.</description></item><item><title/><link>http://localhost/chapter02/08-scale-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/08-scale-pod/</guid><description>Pod 扩容与缩容 代码分支越来越多 增/删/改 都有了， 于是选择拆分为 3 个分支。
// 扩容 func (r *RedisReconciler) increaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 缩容 func (r *RedisReconciler) decreaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 删除 func (r *RedisReconciler) deleteReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } 所谓 扩容/缩容， 在通过 finalizers 管理的时候就是 redis.spec.replicas 与 len(redis.finalizers) 的大小比较。
// 缩容 if len(redis.</description></item><item><title/><link>http://localhost/chapter02/09-watch-k8s-event/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/09-watch-k8s-event/</guid><description>监听 k8s 事件 之前的代码遗留了一个问题， 当手动通过命令删除 pod 时候， 不会出发 redis.Finalizers 的更新， 也不会重建被删除的 Pod， 实现效果并不好
kubectl delete pod pod_name 1. 监听事件 在 /controllers/redis_controller.go 中生成了对象和方法监听 k8s 的事件。
ctrl 创建的 Builder 可以通过 链式 调用方式， 监听多个 k8s 对象的事件。
// SetupWithManager sets up the controller with the Manager. func (r *RedisReconciler) SetupWithManager(mgr ctrl.Manager) error { return ctrl.NewControllerManagedBy(mgr). For(&amp;amp;myappv1.Redis{}). // 监听 pod 事件 Watches( &amp;amp;source.Kind{Type: &amp;amp;corev1.Pod{}}, handler.Funcs{DeleteFunc: r.podDeleteHandler}, ).</description></item><item><title/><link>http://localhost/chapter02/10-recreate-deleted-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/10-recreate-deleted-pod/</guid><description>重建被删除的 Pod 之前遗留了一个问题， 直接用命令行删除的 Pod 不能被重建。 这次就来解决它。
首先来整理之前遗留的问题故障点在哪里？
使用命令 kubectl delete 直接删除 pod 的时候， redis.Finalizers 不会变更， 依旧包含被删除的 pod.Name。 在创建 Pod 的时候， 判断 Pod 是否存在使用的是 redis.Finalizers 提供信息， 而 没有判断 k8s 中真实的情况。 没有机制 通知 redis operator 进行检测或重建。 因此全新流程如下
Pod 状态变化: kubectl delete 删除 Pod Redis 重新调谐: 通知 Redis operator 变化， 重新启动 调谐(Reconcile) 创建 Pod 的逻辑如下 如果 Pod 在 k8s 中存在， 则跳过。 （为了降低复杂性， 不考虑直接改变 redis.finalizers 的情况） 如果 Pod 不存在， 创建 Pod。 是否更新 redis.</description></item><item><title/><link>http://localhost/chapter02/11-official-package-optimize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost/chapter02/11-official-package-optimize/</guid><description>使用 controllerutil 优化代码 在之前的代码中， 对于 OwnerReference 和 Finalizers 操作我们自己实现了一些方法。 其实这些操作官方已经封好成包了， 开箱即用。
复制 /controllers/helper 保存为 /controllers/helper2。 前者保存手工代码， 后者保存优化代码。
https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/controller/controllerutil
Finalizers 操作 之前
// 添加 func appendFinalizers(redis *appv1.Redis, name string){ // 如果 pod.Name 不在 finalizers 中， 则为新增 pod。 // 使用 Finalizer 管理创建的 Pod。 当 pod 被删除完的时候，才能删除 redis redis.Finalizers = append(redis.Finalizers, name) } // 存在判断 func isPodExistInFinalizers2(redis *appv1.Redis, name string) bool { for _, rname := range redis.</description></item></channel></rss>
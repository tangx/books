<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grpc-Go</title><link>https://typonotes.com/books/grpc-go/</link><description>Recent content on Grpc-Go</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://typonotes.com/books/grpc-go/index.xml" rel="self" type="application/rss+xml"/><item><title>1. setup</title><link>https://typonotes.com/books/grpc-go/01-prepare-install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/01-prepare-install/</guid><description>安装工具 ## protoc curl -LO https://github.com/protocolbuffers/protobuf/releases/wnload/v3.19.0/protoc-3.19.0-osx-x86_64.zip unzip -q protoc-3.19.0-osx-x86_64.zip -d protoc &amp;amp;&amp;amp; sudo mv protoc /r/local/bin export PROTOC_BIN=/usr/local/protoc/bin export PATH=&amp;#34;$PROTOC_BIN:$PATH&amp;#34; ## go plugins go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</description></item><item><title>2. 介绍</title><link>https://typonotes.com/books/grpc-go/02-protobuf-introduce/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/02-protobuf-introduce/</guid><description>demo layout . └── pkg └── services // proto 文件及生成的相关接口文件 ├── prod.pb.go // protoc 生成 ├── prod_grpc.pb.go // protoc 生成 ├── prod.proto // 自建 proto 生成的接口文件将成为 server 和 client 都会依赖的 库文件 。 这部分文件应该单独管理， 或通过 CI 在公司内部的公共库进行发布与管理。
proto // 语法版本， 支持 proto2, proto3 // 默认为 proto2 syntax=&amp;#34;proto3&amp;#34;;// 在 go module 模式下 // 需要使用 go_package 生成文件的 package 绝对路径 option go_package = &amp;#34;github.</description></item><item><title>3. 创建 grpc 服务端</title><link>https://typonotes.com/books/grpc-go/03-launch-a-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/03-launch-a-server/</guid><description>创建第一个 grpc 服务 . ├── cmd │ ├── client // 客户端 │ │ └── main.go │ └── server // 服务端 │ └── main.go └── pkg └── services // proto 文件及生成的相关接口文件 └── prod_services.go // 自己新建 实现自己的 prod 服务 自建文件 prod_service.go, 要在此文件中实现自己的 ProdService 逻辑。
protoc 生成的 server 端接口如下
type ProdServiceServer interface { GetProdStock(context.Context, *ProdRequest) (*ProdResponse, error) mustEmbedUnimplementedProdServiceServer() } 有了接口， 创建 struct 对象来不手到擒来？
type ProdService struct { } func (prod *ProdService) GetProdStock(ctx context.</description></item><item><title>4. import 三方依赖</title><link>https://typonotes.com/books/grpc-go/08-import-thirdparty-proto/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/08-import-thirdparty-proto/</guid><description>引用第三方包 在引用第三方包的时候， 不用将其放在自己的工程目录下。 只需要在编译的时候， 只需要使用 --proto_path 添加搜索路径即可正常导入。
例如， 在 order_model.proto 中， 使用了 google 的 timestamp， 文件定义如下:
import &amp;#34;google/protobuf/timestamp.proto&amp;#34;; // 引入文件相对路径 message OrderMain { // ...省略 google.protobuf.Timestamp timestamp=5; // 包名.类型名 }import 的导入路径 下载安装 protoc 时， 压缩包中包含了 goolge 的诸多 proto 文件。 根据文件路径添加 --proto_path=/usr/local/protoc/include/
{ &amp;quot;protoc&amp;quot;: { &amp;quot;path&amp;quot;:&amp;quot;/usr/local/protoc/bin/protoc&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;--proto_path=${workspaceRoot}/&amp;quot;, // 工程目录 &amp;quot;--proto_path=/usr/local/protoc/include/&amp;quot;, // google protos ] } } 就可以在直接在工程 proto 文件中使用
import &amp;#34;google/protobuf/timestamp.</description></item><item><title>4. import 依赖</title><link>https://typonotes.com/books/grpc-go/04-import-proto-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/04-import-proto-file/</guid><description>使用 import 引入其他包 在使用 grpc 的时候，不可避免的会用到 其他 proto 文件。 这时就需要在 proto 文件中使用 import 语法。
如果不了解 import 的路径规则， 那么可能出现以下错误。
Import &amp;quot;model.proto&amp;quot; was not found or had errors. 使用 import 创建 model.proto 定义一个 ProdModel 的消息体(message)
// model.proto syntax=&amp;#34;proto3&amp;#34;;option go_package = &amp;#34;github.com/tangx/grpc-go-demo/pkg/services&amp;#34;;message ProdModel { int32 prod_id=1; string prod_name=2; float prod_price=3;}在 prod.proto 文件中使用 import 引入 model.proto
// prod.proto syntax=&amp;#34;proto3&amp;#34;;option go_package = &amp;#34;github.com/tangx/grpc-go-demo/pkg/services&amp;#34;;package grpc_go_demo.prod;// 引入文件 import &amp;#34;pkg/services/model.proto&amp;#34;;service ProdService { rpc GetProdStock(ProdRequest) returns (ProdResponse); rpc GetProdModel(ProdRequest) returns (ProdModel); // 添加新接口 }虽然 prod.</description></item><item><title>5. repeated 返回数组</title><link>https://typonotes.com/books/grpc-go/05-repeated-return-slice-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/05-repeated-return-slice-type/</guid><description>使用 repeated 返回数组或切片 在 proto 如果要表示某个字段是数组， 需要在定义某一个字段的时候使用 repeated 作为修饰符。
如下
message ProdResponse{ int32 prod_stock=1; // 商品库存 }message ProdResponseList { repeated ProdResponse prods=1; // ProdResponse 数组 }编译结果如下
type ProdResponseList struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Prods []*ProdResponse `protobuf:&amp;#34;bytes,1,rep,name=prods,proto3&amp;#34; json:&amp;#34;prods,omitempty&amp;#34;` }</description></item><item><title>6. 枚举类型</title><link>https://typonotes.com/books/grpc-go/06-enum-type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/06-enum-type/</guid><description>枚举类型 在 proto 中定义一个 枚举 类型还是很简单的
enum ProdArea { A=0; // 第一个必须是0 ， 表示默认值 B=1; C=2;}在 proto3 语法中， 定义枚举类型的第一个枚举值必须为 0 ， 否则编译将报错（如下）。 同时该枚举值也是 默认值 。
protos/services/prod_enum.proto:6:7: The first enum value must be zero in proto3. 在编译成 go 以后， 对应创建了一个新的类型 ProdArea， 以及初始化一些 常量。
type ProdArea int32 const ( ProdArea_A ProdArea = 0 // 第一个必须是0 ， 表示默认值 ProdArea_B ProdArea = 1 ProdArea_C ProdArea = 2 ) 同时， ProdArea 提供了 String() 方法得到 枚举值 的字面量。</description></item><item><title>7. 编译成 Golang 依赖</title><link>https://typonotes.com/books/grpc-go/07-protoc-compile-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://typonotes.com/books/grpc-go/07-protoc-compile-in-go/</guid><description>protoc 编译 go module 特有参数 https://developers.google.com/protocol-buffers/docs/reference/go-generated#invocation
实现 proto 与 go 代码分离 如果将编译后生成的代码文件和 proto 文件放在一起的话， 目录内文件看起来乱糟糟的， 当然也不是什么大事。 但如果要为不同语言编译对应的库文件， 就不方便进行管理了。
如下， proto 文件单独一个分支目录， 编译的 go 文件单独一个分支目录。 就清爽多了。
. ├── pkg │ └── services │ ├── prod.pb.go │ ├── prod_enum.pb.go │ └── prod_server_grpc.pb.go └── protos └── services ├── prod.proto ├── prod_enum.proto └── prod_server.proto 在 proto 文件中， 其中有一个 go 特有的参数 option go_package， 其作用就是指定编译后生成文件的存放路径， 也就是 go 中 import 此包的地址。</description></item></channel></rss>